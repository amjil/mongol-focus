(ns minii-focus.logic.db
  (:require ["package:cljd_mongol_focus/database.dart" :as drift]
            ["package:drift/drift.dart" :as d]
            ["dart:core" :as dc]
            ["dart:async" :as async]
            [clojure.string :as str]))

;; =============================================================================
;; 1. Database Instance Management
;; =============================================================================

(defonce db (atom nil))

(defn initialize-database!
  "Initialize the database. Call this function with await directly in f/run's :init."
  []
  (let [instance (await (drift/initDriftDatabase))]
    (reset! db instance)
    (dart:core/print "Minii Focus SQLite database connection successful (Reactive Mode)")))

;; =============================================================================
;; 2. Reactive Queries (Returns Dart Streams)
;; =============================================================================

(defn watch-active-tasks
  "Watch the stream of active tasks.
   Logic: Uncompleted tasks (is_done = false) without parent (parent_id is null), sorted by display_order in ascending order."
  []
  (if-let [^drift/AppDatabase database @db]
    (.watch
     (.customSelect
      database
      "SELECT 
       t.*, 
       c.name as category_name, 
       c.icon_code as category_icon,
        (SELECT COUNT(*) FROM tasks WHERE parent_id = t.id) as subtask_count,
        (SELECT COUNT(*) FROM tasks WHERE parent_id = t.id AND is_done = 1) as subtask_done_count
       FROM tasks t
        LEFT JOIN categories c ON t.category_id = c.id
       WHERE t.is_done = false AND t.parent_id IS NULL
       ORDER BY t.display_order ASC, t.created_at DESC"
      .readsFrom #{(.-tasks database) (.-categories database)}))
    (async/Stream.empty)))

(defn watch-tasks-filtered
  "Filter tasks by keyword and category ID (excluding subtasks)"
  [{:keys [search-term category-id]}]
  (let [query (str "SELECT t.*, c.name as category_name, c.icon_code as category_icon "
                   "FROM tasks t LEFT JOIN categories c ON t.category_id = c.id "
                   "WHERE t.is_done = false AND t.parent_id IS NULL "
                   (when-not (str/blank? search-term)
                     "AND (t.title LIKE ? OR t.notes LIKE ?) ")
                   (when category-id
                     "AND t.category_id = ? ")
                   "ORDER BY t.display_order ASC")
        vars (cond-> []
               (not (str/blank? search-term)) (conj (str "%" search-term "%") (str "%" search-term "%"))
               category-id (conj category-id))]
    (if-let [^drift/AppDatabase database @db]
      (.watch (.customSelect database query .variables (map #(d/Variable. %) vars)))
      (async/Stream.empty))))


(defn watch-tasks-by-category
  "Watch task stream by category."
  [cat-id]
  (if-let [^drift/AppDatabase database @db]
    (.watch
     (.customSelect
      database
      "SELECT * FROM tasks WHERE category_id = ? AND is_done = false ORDER BY display_order ASC"
      .variables [(d/Variable cat-id)]))
    (async/Stream.empty)))

(defn watch-logbook
  "Watch the logbook stream.
   Logic: Completed tasks (is_done = true) without parent, sorted by completed_at in descending order."
  []
  (if-let [^drift/AppDatabase database @db]
    (.watch
     (.customSelect
      database
      "SELECT 
       t.*, 
       c.name as category_name, 
       c.icon_code as category_icon
       FROM tasks t
        LEFT JOIN categories c ON t.category_id = c.id
       WHERE t.is_done = true AND t.parent_id IS NULL
       ORDER BY t.display_order ASC, t.created_at DESC"
      .readsFrom #{(.-tasks database) (.-categories database)}))
    (async/Stream.empty)))

(defn watch-all-categories
  "Watch all category lists in the sidebar."
  []
  (if-let [^drift/AppDatabase database @db]
    (.watch (.select database (.-categories database)))
    (async/Stream.empty)))

(defn watch-subtasks
  "Watch subtasks for a parent task."
  [parent-id]
  (if-let [^drift/AppDatabase database @db]
    (.watch
     (.customSelect
      database
      "SELECT 
       t.*, 
       c.name as category_name, 
       c.icon_code as category_icon
       FROM tasks t
        LEFT JOIN categories c ON t.category_id = c.id
       WHERE t.parent_id = ?
       ORDER BY t.display_order ASC, t.created_at ASC"
      .variables [(d/Variable parent-id)]
      .readsFrom #{(.-tasks database) (.-categories database)}))
    (async/Stream.empty)))

(defn watch-subtask-count
  "Watch the count of subtasks for a parent task."
  [parent-id]
  (if-let [^drift/AppDatabase database @db]
    (.watch
     (.customSelect
      database
      "SELECT COUNT(*) as count FROM tasks WHERE parent_id = ?"
      .variables [(d/Variable parent-id)]
      .readsFrom #{(.-tasks database)}))
    (async/Stream.empty)))

;; =============================================================================
;; 3. Write Operations (CRUD)
;; =============================================================================

(defn add-task!
  [{:keys [title notes category-id priority parent-id] :or {priority 0}}]
  (if-let [^drift/AppDatabase database @db]
    (let [companion (drift/TasksCompanion.insert
                      :title title
                      :notes (if notes (d/Value ^String notes) (d/Value.absent))
                      ;; Use Value(null) with type annotation for nullable int fields
                      :categoryId (if category-id 
                                    (d/Value ^int category-id) 
                                    (d/Value nil))
                      :parentId (if parent-id
                                  (d/Value ^int parent-id)
                                  (d/Value nil))
                      :priority (d/Value ^int priority)
                      :isDone (d/Value false)
                      :displayOrder (d/Value 0.0))]
      (.insert (.into database (.-tasks database)) companion))
    (throw (ex-info "Database not initialized" {}))))

(defn toggle-task-status!
  "Toggle task status.
   If is-done is true, automatically record the completion time (completed_at)."
  [id is-done]
  (if-let [^drift/AppDatabase database @db]
    (let [now (dart:core/DateTime.now)
          query (doto (.update database (.-tasks database))
                  (.where (fn [tbl] (.equals (.-id tbl) id))))]
      (.write query
              (drift/TasksCompanion.
               .isDone (d/Value ^bool is-done)
               .completedAt (if is-done (d/Value ^dc/DateTime? now) (d/Value.absent)))))
    (throw (ex-info "Database not initialized" {}))))

(defn string-value [v]
  (if (nil? v)
    (d/Value.absent)
    (d/Value. ^String v)))

(def task-field->companion
  {:due-date
   (fn [v]
     (drift/TasksCompanion.
      .dueDate (if (nil? v)
                 (d/Value.absent)
                 (d/Value ^dc/DateTime? v))))

   :priority
   (fn [v]
     (drift/TasksCompanion.
      .priority (d/Value ^int v)))

   :category-id
   (fn [v]
     (if (nil? v)
       (d/Value nil)
       (d/Value ^int v)))

   :title-and-notes
   (fn [{:keys [title notes]}]
     (let [title (string-value title)
           notes (string-value notes)]
       (drift/TasksCompanion.
        .title title
        .notes notes)))

   :reminder-at
   (fn [v]
     (drift/TasksCompanion.
      .reminderAt (if (nil? v)
                    (d/Value nil)
                    (d/Value ^dc/DateTime v))))

   :is-done
   (fn [v]
     (drift/TasksCompanion.
      .isDone (d/Value ^bool v)))})

(defn update-task!
  [id field value]
  (if-let [build (get task-field->companion field)]
    (if-let [^drift/AppDatabase db-inst @db]
      (let [query (doto (.update db-inst (.-tasks db-inst))
                    (.where (fn [tbl]
                              (.equals (.-id tbl) id))))
            companion (build value)]
        (.write query companion))
      (throw (ex-info "Database not initialized" {})))
    (throw (ex-info "Unknown task field" {:field field}))))

(defn delete-task!
  "Permanently delete a task."
  [id]
  (if-let [^drift/AppDatabase database @db]
    (.go
     (doto (.delete database (.-tasks database))
       (.where (fn [tbl] (.equals (.-id tbl) id)))))
    (throw (ex-info "Database not initialized" {}))))

(defn update-task-order!
  "Update task sort weight (for drag and drop reordering)."
  [id new-order]
  (if-let [^drift/AppDatabase database @db]
    (let [query (doto (.update database (.-tasks database))
                  (.where (fn [tbl] (.equals (.-id tbl) id))))]
      (.write query (drift/TasksCompanion. .displayOrder (d/Value new-order))))
    (throw (ex-info "Database not initialized" {}))))

;; =============================================================================
;; 4. Category Operations
;; =============================================================================

(defn add-category!
  "Create a new list category."
  [name icon-code]
  (if-let [^drift/AppDatabase database @db]
    (let [companion (drift/CategoriesCompanion.insert
                     .name name
                     .iconCode (if icon-code (d/Value icon-code) (d/Value.absent)))]
      (.insert (.into database (.-categories database)) companion))
    (throw (ex-info "Database not initialized" {}))))


(defn delete-category! [id]
  (if-let [^drift/AppDatabase db-inst @db]
    (.go
     (doto (.delete db-inst (.-categories db-inst))
       (.where (fn [tbl] (.equals (.-id tbl) (d/Variable. id))))))
    (throw (ex-info "Database not initialized" {}))))


(defn watch-categories
  "Watch all category lists using SQL.
   Logic: Sorted by id (or you can change it to display_order)."
  []
  (if-let [^drift/AppDatabase database @db]
    (.watch
     (.customSelect
      database
      "SELECT * FROM categories ORDER BY id ASC"))
    (async/Stream.empty)))