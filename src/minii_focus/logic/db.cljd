(ns minii-focus.logic.db
  (:require ["package:cljd_mongol_focus/database.dart" :as drift]
            ["package:drift/drift.dart" :as d]
            ["dart:core" :as dc]
            ["dart:async" :as async]
            [clojure.string :as str]))

;; =============================================================================
;; 1. Database Instance Management
;; =============================================================================

(defonce db (atom nil))

(defn initialize-database!
  "Initialize the database. Call this function with await directly in f/run's :init."
  []
  (let [instance (await (drift/initDriftDatabase))]
    (reset! db instance)
    (dart:core/print "Minii Focus SQLite database connection successful (Reactive Mode)")))

;; =============================================================================
;; 2. Reactive Queries (Returns Dart Streams)
;; =============================================================================

(defn watch-active-tasks
  "Watch the stream of active tasks.
   Logic: Uncompleted tasks (is_done = false) without parent (parent_id is null), sorted by display_order in ascending order."
  []
  (if-let [^drift/AppDatabase database @db]
    (.watch
     (.customSelect
      database
      "SELECT 
       t.*, 
       c.name as category_name, 
       c.icon_code as category_icon,
        (SELECT COUNT(*) FROM tasks WHERE parent_id = t.id) as subtask_count,
        (SELECT COUNT(*) FROM tasks WHERE parent_id = t.id AND is_done = 1) as subtask_done_count
       FROM tasks t
        LEFT JOIN categories c ON t.category_id = c.id
       WHERE t.is_done = false AND t.parent_id IS NULL
       ORDER BY t.display_order ASC, t.created_at DESC"
      .readsFrom #{(.-tasks database) (.-categories database)}))
    (async/Stream.empty)))

(defn watch-tasks-filtered
  "Filter tasks by keyword, category ID, and due date (excluding subtasks)"
  [{:keys [search-term category-id due-date]}]
  (let [query (str "SELECT t.*, c.name as category_name, c.icon_code as category_icon "
                   "FROM tasks t LEFT JOIN categories c ON t.category_id = c.id "
                   "WHERE t.is_done = false AND t.parent_id IS NULL "
                   (when-not (str/blank? search-term)
                     "AND (t.title LIKE ? OR t.notes LIKE ?) ")
                   (when category-id
                     "AND t.category_id = ? ")
                   (when due-date
                     "AND t.due_date IS NOT NULL AND DATE(t.due_date) = DATE(?) ")
                   "ORDER BY t.display_order ASC")
        vars (cond-> []
               (not (str/blank? search-term)) (conj (str "%" search-term "%") (str "%" search-term "%"))
               category-id (conj category-id)
               due-date (conj due-date))]
    (if-let [^drift/AppDatabase database @db]
      (.watch (.customSelect database query .variables (map #(d/Variable. %) vars)))
      (async/Stream.empty))))


(defn watch-tasks-by-category
  "Watch task stream by category."
  [cat-id]
  (if-let [^drift/AppDatabase database @db]
    (.watch
     (.customSelect
      database
      "SELECT * FROM tasks WHERE category_id = ? AND is_done = false ORDER BY display_order ASC"
      .variables [(d/Variable cat-id)]))
    (async/Stream.empty)))

(defn watch-logbook
  "Watch the logbook stream.
   Logic: Completed tasks (is_done = true) without parent, sorted by completed_at in descending order."
  []
  (if-let [^drift/AppDatabase database @db]
    (.watch
     (.customSelect
      database
      "SELECT 
       t.*, 
       c.name as category_name, 
       c.icon_code as category_icon
       FROM tasks t
        LEFT JOIN categories c ON t.category_id = c.id
       WHERE t.is_done = true AND t.parent_id IS NULL
       ORDER BY t.display_order ASC, t.created_at DESC"
      .readsFrom #{(.-tasks database) (.-categories database)}))
    (async/Stream.empty)))

(defn watch-all-categories
  "Watch all category lists in the sidebar."
  []
  (if-let [^drift/AppDatabase database @db]
    (.watch (.select database (.-categories database)))
    (async/Stream.empty)))

(defn watch-subtasks
  "Watch subtasks for a parent task."
  [parent-id]
  (if-let [^drift/AppDatabase database @db]
    (.watch
     (.customSelect
      database
      "SELECT 
       t.*, 
       c.name as category_name, 
       c.icon_code as category_icon
       FROM tasks t
        LEFT JOIN categories c ON t.category_id = c.id
       WHERE t.parent_id = ?
       ORDER BY t.display_order ASC, t.created_at ASC"
      .variables [(d/Variable parent-id)]
      .readsFrom #{(.-tasks database) (.-categories database)}))
    (async/Stream.empty)))

(defn watch-subtask-count
  "Watch the count of subtasks for a parent task."
  [parent-id]
  (if-let [^drift/AppDatabase database @db]
    (.watch
     (.customSelect
      database
      "SELECT COUNT(*) as count FROM tasks WHERE parent_id = ?"
      .variables [(d/Variable parent-id)]
      .readsFrom #{(.-tasks database)}))
    (async/Stream.empty)))

;; =============================================================================
;; 3. Write Operations (CRUD)
;; =============================================================================

(defn add-task!
  [{:keys [title notes category-id priority parent-id recurrence-mode] :or {priority 0 recurrence-mode 0}}]
  (if-let [^drift/AppDatabase database @db]
    (let [companion (drift/TasksCompanion.insert
                     :title title
                     :notes (if notes (d/Value ^String notes) (d/Value.absent))
                     ;; Use Value(null) with type annotation for nullable int fields
                     :categoryId (if category-id
                                   (d/Value ^int category-id)
                                   (d/Value nil))
                     :parentId (if parent-id
                                 (d/Value ^int parent-id)
                                 (d/Value nil))
                     :priority (d/Value ^int priority)
                     :isDone (d/Value false)
                     :displayOrder (d/Value 0.0)
                     :recurrenceMode (d/Value ^int recurrence-mode))]
      (.insert (.into database (.-tasks database)) companion))
    (throw (ex-info "Database not initialized" {}))))

(defn toggle-task-status!
  "Toggle task status.
   If is-done is true, automatically record the completion time (completed_at)."
  [id is-done]
  (if-let [^drift/AppDatabase database @db]
    (let [now (dart:core/DateTime.now)
          query (doto (.update database (.-tasks database))
                  (.where (fn [tbl] (.equals (.-id tbl) id))))]
      (.write query
              (drift/TasksCompanion.
               .isDone (d/Value ^bool is-done)
               .completedAt (if is-done (d/Value ^dc/DateTime? now) (d/Value.absent)))))
    (throw (ex-info "Database not initialized" {}))))

(defn string-value [v]
  (if (nil? v)
    (d/Value.absent)
    (d/Value. ^String v)))

(def task-field->companion
  {:due-date
   (fn [v]
     (drift/TasksCompanion.
      .dueDate (if (nil? v)
                 (d/Value.absent)
                 (d/Value ^dc/DateTime? v))))

   :priority
   (fn [v]
     (drift/TasksCompanion.
      .priority (d/Value ^int v)))

   :category-id
   (fn [v]
     (if (nil? v)
       (d/Value nil)
       (d/Value ^int v)))

   :title-and-notes
   (fn [{:keys [title notes]}]
     (let [title (string-value title)
           notes (string-value notes)]
       (drift/TasksCompanion.
        .title title
        .notes notes)))

   :reminder-at
   (fn [v]
     (drift/TasksCompanion.
      .reminderAt (if (nil? v)
                    (d/Value nil)
                    (d/Value ^dc/DateTime v))))
                    
   :recurrence-mode
   (fn [v]
     (drift/TasksCompanion.
      .recurrenceMode (d/Value ^int v)))

   :is-done
   (fn [v]
     (drift/TasksCompanion.
      .isDone (d/Value ^bool v)))})
      
(defn get-task-by-id [id]
  (if-let [^drift/AppDatabase database @db]
    (.getSingleOrNull
     (doto (.select database (.-tasks database))
       (.where (fn [^drift/Tasks tbl] (.equals (.-id tbl) id)))))
    (throw (ex-info "Database not initialized" {}))))

(defn update-task!
  [id field value]
  (if-let [build (get task-field->companion field)]
    (if-let [^drift/AppDatabase db-inst @db]
      (let [query (doto (.update db-inst (.-tasks db-inst))
                    (.where (fn [tbl]
                              (.equals (.-id tbl) id))))
            companion (build value)]
        (.write query companion))
      (throw (ex-info "Database not initialized" {})))
    (throw (ex-info "Unknown task field" {:field field}))))

(defn- add-months [^dc/DateTime dt n]
  (let [new-month (+ (.-month dt) n)
        year-adjust (quot (dec new-month) 12)
        final-month (let [m (rem new-month 12)] (if (zero? m) 12 m))
        final-year (+ (.-year dt) year-adjust)
        ;; Get the number of days in the target month (by subtracting 1 day from the first day of next month)
        next-month-first (if (= final-month 12)
                           (dc/DateTime. (inc final-year) 1 1)
                           (dc/DateTime. final-year (inc final-month) 1))
        last-day-of-month (-> next-month-first
                             (.subtract (dc/Duration. .days 1))
                             (.-day))
        ;; Use the smaller value between the original day and the number of days in the target month
        safe-day (min (.-day dt) last-day-of-month)]
    (dc/DateTime. final-year final-month safe-day (.-hour dt) (.-minute dt))))
    
(defn handle-task-completion! [id is-done]
  (let [task (await (get-task-by-id id))
        mode (get task "recurrence_mode" 0)]
    (when (and (true? is-done) (> mode 0))
      ;; --- Handle recurrence task ---
      (let [current-due (or (get task "due_date") (dc/DateTime.now))
            next-due (cond
                       (= mode 1) (.add current-due (dc/Duration. .days 1))   ; Daily
                       (= mode 2) (.add current-due (dc/Duration. .days 7))   ; Weekly
                       (= mode 3) (add-months current-due 1)                   ; Monthly
                       :else nil)]
        (when next-due
          ;; Clone a new task to the database
          (await (add-task! {:title (.-title task)
                             :notes (get task "notes")
                             :category-id (get task "category_id")
                             :priority (get task "priority")
                             :due-date next-due
                             :recurrence-mode mode})))))))

(defn delete-task!
  "Permanently delete a task."
  [id]
  (if-let [^drift/AppDatabase database @db]
    (.go
     (doto (.delete database (.-tasks database))
       (.where (fn [tbl] (.equals (.-id tbl) id)))))
    (throw (ex-info "Database not initialized" {}))))

(defn update-task-order!
  "Update task sort weight (for drag and drop reordering)."
  [id new-order]
  (if-let [^drift/AppDatabase database @db]
    (let [query (doto (.update database (.-tasks database))
                  (.where (fn [tbl] (.equals (.-id tbl) id))))]
      (.write query (drift/TasksCompanion. .displayOrder (d/Value new-order))))
    (throw (ex-info "Database not initialized" {}))))

;; =============================================================================
;; 4. Category Operations
;; =============================================================================

(defn add-category!
  "Create a new list category."
  [name icon-code]
  (if-let [^drift/AppDatabase database @db]
    (let [companion (drift/CategoriesCompanion.insert
                     .name name
                     .iconCode (if icon-code (d/Value icon-code) (d/Value.absent)))]
      (.insert (.into database (.-categories database)) companion))
    (throw (ex-info "Database not initialized" {}))))


(defn delete-category! [id]
  (if-let [^drift/AppDatabase db-inst @db]
    (.go
     (doto (.delete db-inst (.-categories db-inst))
       (.where (fn [tbl] (.equals (.-id tbl) (d/Variable. id))))))
    (throw (ex-info "Database not initialized" {}))))


(defn watch-categories
  "Watch all category lists using SQL.
   Logic: Sorted by id (or you can change it to display_order)."
  []
  (if-let [^drift/AppDatabase database @db]
    (.watch
     (.customSelect
      database
      "SELECT * FROM categories ORDER BY id ASC"))
    (async/Stream.empty)))