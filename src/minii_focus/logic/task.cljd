(ns minii-focus.logic.task
  (:require [clojure.string :as str]))

;; --- Pure Functions: Not dependent on any UI framework ---

(defn mark-done [items id]
  (mapv (fn [item]
          (if (and (= (:type item) :task) (= (:id item) id))
            (update item :is-done? not)
            item))
        items))

(defn delete-it [items id]
  (filterv (fn [item]
             (or (not= (:type item) :task)
                 (not= (:id item) id)))
           items))

(defn reorder-done-to-bottom [items id]
  (let [task (first (filter #(= (:id %) id) items))
        others (filterv #(not= (:id %) id) items)]
    (if task
      (conj others task)
      items)))

(defn add-task [items text]
  (let [new-task {:id (.toString (dart:core/DateTime.now))
                  :type :task
                  :text text
                  :is-done? false}]
    ;; Insert after search bar (assuming it's the first item)
    (vec (cons (first items) 
               (cons new-task (rest items))))))


(defn- has-active-tasks?
  "Starting from current position, search forward until next header, check if there are uncompleted tasks"
  [items start-idx]
  (->> (subvec items (inc start-idx)) ;; Get all elements after current element
       (take-while #(not= (:type %) :header)) ;; Only look at tasks belonging to this group
       (some #(and (= (:type %) :task) (not (:is-done? %)))))) ;; Check if there are active tasks

(defn get-visible-items
  "Filter out empty group titles according to business rules"
  [items]
  (if (empty? items)
    []
    (reduce-kv
     (fn [acc idx item]
       (cond
         ;; 1. If it's a search box, always keep it
         (= (:type item) :search)
         (conj acc item)

         ;; 2. If it's a group title, check if there are uncompleted tasks after it
         (= (:type item) :header)
         (if (has-active-tasks? items idx)
           (conj acc item)
           acc) ;; All tasks in this group are completed, hide title

         ;; 3. If it's a task, decide according to your needs:
         ;; Option A: Hide completed tasks (like Things' todo view)
         ;; Option B: Always show (completed ones will be at the end)
         (= (:type item) :task)
         (if-not (:is-done? item)
           (conj acc item)
           acc) ;; Temporarily hide completed tasks here to keep the interface clean

         :else acc))
     []
     items)))


