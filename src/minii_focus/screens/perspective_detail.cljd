(ns minii-focus.screens.perspective-detail
  (:require
   ["package:flutter/material.dart" :as m]
   ["package:mongol/mongol.dart" :as mgl]
   [cljd.flutter :as f]
   [minii-focus.core.components.core :as comp]
   [minii-focus.core.components.tokens :as tokens]
   [minii-focus.core.state.app-state :as app-state]
   [minii-focus.core.db.perspective :as perspective-db]
   [minii-focus.core.dao.perspective :as perspective-dao]
   [minii-focus.core.event.dispatch :as dispatch]
   [minii-focus.core.utils.toast :as toast]
   [minii-focus.core.utils.logger :as logger]
   [minii-focus.core.domain.perspective.filters :as filters]
   [minii-focus.widgets.common :as widgets]
   [minii-focus.widgets.filter-editor :as filter-editor]
   [minii-focus.screens.task-detail :as task-detail]))

(defn filter-editor-card 
  "Filter Editor Card - Use visual editor instead of JSON editing"
  [ctx db-ctx perspective current-filters on-filters-change]
  (m/Card
   .margin (m/EdgeInsets.all (tokens/space :m))
   .child (m/Padding
           .padding (m/EdgeInsets.all (tokens/space :m))
           .child (m/Column
                   .crossAxisAlignment m/CrossAxisAlignment.start
                   .children [(filter-editor/filter-editor
                              {:filters current-filters
                               :on-filters-change (fn [new-filters]
                                                   (on-filters-change new-filters))
                               :context ctx})
                             (m/SizedBox .height (tokens/space :m))
                             (m/ElevatedButton
                              .onPressed (fn []
                                          (let [filters-json (filters/filters-to-json current-filters)]
                                            (-> (dispatch/dispatch-event! db-ctx
                                                                          {:type :perspective/update-rules
                                                                           :payload {:perspective-id (.-id perspective)
                                                                                     :rules filters-json}
                                                                           :source :ui})
                                                (.then (fn [_]
                                                        (toast/show-success-toast ctx "Filters saved"))))))
                              .child (comp/mongol-text-block {:text "Save Filters"}))]))))

;; Map from query result is already in the right format, no conversion needed

(defn perspective-detail-screen [params]
  (let [pid (:id params)
        filters-state-atom (atom [])
        last-loaded-rules-atom (atom nil)
        query-result-atom (atom {:data [] :loading false :error nil})
        last-query-filters-atom (atom nil)]
    (f/widget
     :context ctx
     :watch [dao app-state/dao
             perspective-res (when dao (future (-> (perspective-db/get-by-id dao pid)
                                                   (.then (fn [p] {:data p})))))
             filters-state filters-state-atom
             query-result query-result-atom]
     :let [loading (or (nil? dao) (nil? perspective-res))
           perspective (:data perspective-res)
           db-ctx {:db (app-state/get-db) :dao dao}
           _ (when (and (not loading) perspective)
               (let [current-rules (or (.-rules perspective) "[]")]
                 ;; Parse filters from rules JSON (reload only when rules change)
                 (when (not= @last-loaded-rules-atom current-rules)
                   (let [parsed-filters (filters/json-to-filters current-rules)]
                     ;; Use addPostFrameCallback to defer execution, avoid calling setState during build
                     (.addPostFrameCallback (.-instance m/WidgetsBinding)
                                            (fn [_]
                                              (reset! filters-state-atom parsed-filters)
                                              (reset! last-loaded-rules-atom current-rules)
                                              ;; Reset query state when filters change
                                              (reset! query-result-atom {:data [] :loading false :error nil})
                                              (reset! last-query-filters-atom nil)))
                     nil))))
           current-filters filters-state
           db-instance (app-state/get-db)
           _ (when (and (not loading) perspective db-instance (not (empty? current-filters)))
               (let [query-loading (:loading @query-result-atom)
                     query-error (:error @query-result-atom)
                     filters-changed? (not= @last-query-filters-atom current-filters)]
                 ;; Only query if:
                 ;; 1. Not currently loading
                 ;; 2. No error from previous query (or filters changed)
                 ;; 3. Filters changed since last query
                 (when (and (not query-loading)
                           (or (nil? query-error) filters-changed?)
                           filters-changed?)
                   (reset! query-result-atom {:data [] :loading true :error nil})
                   (reset! last-query-filters-atom current-filters)
                   (-> (perspective-dao/query-by-perspective! db-instance {:entity :task
                                                                           :filters current-filters})
                       (.then (fn [results]
                                (reset! query-result-atom {:data results :loading false :error nil})))
                       (.catchError (fn [error]
                                     (logger/error "perspective-detail" "perspective查询失败" {:perspective-id pid
                                                                                        :error (str error)})
                                     ;; Set error state to prevent infinite retry
                                     (reset! query-result-atom {:data [] :loading false :error (str error)})))))))
           tasks (if loading
                  []
                  (let [query-data (:data query-result)
                        result query-data]
                    result))]
     (m/Scaffold
      .appBar (m/AppBar)
      .body (m/SafeArea
             .child (if loading
                      (widgets/loading-indicator)
                      (if (nil? perspective)
                        (widgets/empty-state "Perspective not found")
                        (m/ListView
                         .scrollDirection m/Axis.horizontal
                         .children
                         [(m/Padding
                           .padding (m/EdgeInsets.all (tokens/space :m))
                           .child (m/Column
                                   .crossAxisAlignment m/CrossAxisAlignment.start
                                   .children
                                   [(comp/mongol-text-block {:text "Weight History" :style (m/TextStyle .fontWeight m/FontWeight.bold)})
                                    (widgets/weight-history-chart {:weight-history (widgets/parse-json (.-weightHistory perspective))})
                                    (m/SizedBox .height (tokens/space :m))
                                    (comp/mongol-text-block {:text (str "Current Weight: " (int (* (.-weight perspective) 100)) "%")})]))
                          (filter-editor-card ctx db-ctx perspective current-filters
                                              (fn [new-filters]
                                                (reset! filters-state-atom new-filters)))
                          (m/Padding
                           .padding (m/EdgeInsets.all (tokens/space :m))
                           .child (comp/mongol-text-block {:text "Tasks" :style (m/TextStyle .fontWeight m/FontWeight.bold)}))
                          (m/Row
                           .children
                           (mapv (fn [t]
                                   (let [task-id (get t "id")
                                         card-content (m/Card
                                                       .margin (m/EdgeInsets.symmetric :vertical 4 :horizontal 16)
                                                       .child (mgl/MongolListTile
                                                               .title (comp/mongol-text-block {:text (get t "title")})
                                                               .trailing (if (get t "completed") (m/Icon m/Icons.check_circle .color m/Colors.green) nil)))]
                                     (m/InkWell
                                      .onTap (fn []
                                               (let [navigator (m/Navigator.of ctx)
                                                     task-detail-page (m/MaterialPageRoute
                                                                       .builder (fn [_build-ctx]
                                                                                 (task-detail/task-detail-screen {:id task-id})))]
                                                 (-> navigator (.push task-detail-page)))
                                               nil)
                                      .child card-content)))
                                 tasks))]))))))))
