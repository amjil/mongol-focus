(ns minii-focus.services.tag
  "Tag management service"
  (:require
   ["dart:core" :as dart-core]
   ["package:cljd_mongol_focus/database/database.dart" :as drift]
   [minii-focus.services.database :as db]
   [minii-focus.states.app-state :as state]
   [minii-focus.utils.ids :as ids]
   [minii-focus.utils.toast :as toast]
   [minii-focus.utils.refresh :as refresh]))

;; =============================================================================
;; Tag CRUD operations
;; =============================================================================

(defn create-tag
  "Create tag
  Options:
  - :name - tag name (required)
  - :parent-id - parent tag ID (optional)
  - :context-type - context type: \"location\", \"tool\", \"person\", or nil for regular tag (optional)"
  [{:keys [name parent-id context-type]}]
  (let [^drift/AppDatabase database (db/get-database)
        tag-id (ids/generate-id)
        tags-dao (.-tagsDao database)
        create-future (cond
                        (and parent-id context-type)
                        (.createTag tags-dao tag-id name .parentId parent-id .contextType context-type)
                        parent-id
                        (.createTag tags-dao tag-id name .parentId parent-id)
                        context-type
                        (.createTag tags-dao tag-id name .contextType context-type)
                        :else
                        (.createTag tags-dao tag-id name))]
    (-> create-future
        (.then (fn [_] tag-id)))))

(defn update-tag
  "Update tag
  Options:
  - :name - tag name (optional)
  - :parent-id - parent tag ID (optional)
  - :context-type - context type: \"location\", \"tool\", \"person\", or nil for regular tag (optional)"
  [id {:keys [name parent-id context-type]}]
  (let [^drift/AppDatabase database (db/get-database)
        tags-dao (.-tagsDao database)]
    (cond
      (and name parent-id context-type)
      (.updateTag tags-dao id .name name .parentId parent-id .contextType context-type)
      (and name parent-id)
      (.updateTag tags-dao id .name name .parentId parent-id)
      (and name context-type)
      (.updateTag tags-dao id .name name .contextType context-type)
      (and parent-id context-type)
      (.updateTag tags-dao id .parentId parent-id .contextType context-type)
      name
      (.updateTag tags-dao id .name name)
      parent-id
      (.updateTag tags-dao id .parentId parent-id)
      context-type
      (.updateTag tags-dao id .contextType context-type)
      :else
      (.updateTag tags-dao id))))

(defn delete-tag
  "Delete tag (also deletes associations)"
  [id]
  (let [^drift/AppDatabase database (db/get-database)
        tags-dao (.-tagsDao database)]
    (.deleteTag tags-dao id)))

(defn get-tag-by-id
  "Get tag by ID"
  [id]
  (let [^drift/AppDatabase database (db/get-database)
        tags-dao (.-tagsDao database)]
    (.getTagById tags-dao id)))

(defn get-all-tags
  "Get all tags"
  []
  (let [^drift/AppDatabase database (db/get-database)
        tags-dao (.-tagsDao database)]
    (.getAllTags tags-dao)))

(defn get-contexts
  "Get all contexts (tags with contextType not null)"
  []
  (-> (get-all-tags)
      (.then (fn [tags]
               (filter (fn [tag]
                        (some? (.-contextType tag)))
                      tags)))))

(defn get-contexts-by-type
  "Get contexts by type: \"location\", \"tool\", or \"person\""
  [context-type]
  (-> (get-all-tags)
      (.then (fn [tags]
               (filter (fn [tag]
                        (= context-type (.-contextType tag)))
                      tags)))))

(defn get-regular-tags
  "Get regular tags (contextType is null)"
  []
  (-> (get-all-tags)
      (.then (fn [tags]
               (filter (fn [tag]
                        (nil? (.-contextType tag)))
                      tags)))))

;; =============================================================================
;; Page data loading/refresh (side effects in service)
;; =============================================================================

(defn refresh-tags!
  "Refresh tag list and write to app-state"
  []
  (refresh/with-loading-state
   get-all-tags
   state/set-tags-loading!
   state/set-tags!
   "Тагийг шинэчлэхэд алдаа гарлаа"))

(defn get-tags-by-parent
  "Get all child tags of specified parent tag"
  [parent-id]
  (let [^drift/AppDatabase database (db/get-database)
        tags-dao (.-tagsDao database)]
    (.getTagsByParent tags-dao parent-id)))

;; =============================================================================
;; Tag and task associations
;; =============================================================================

(defn add-tag-to-item
  "Add tag to task"
  [item-id tag-id]
  (let [^drift/AppDatabase database (db/get-database)
        tags-dao (.-tagsDao database)]
    (.addTagToItem tags-dao item-id tag-id)))

(defn remove-tag-from-item
  "Remove tag from task"
  [item-id tag-id]
  (let [^drift/AppDatabase database (db/get-database)
        tags-dao (.-tagsDao database)]
    (.removeTagFromItem tags-dao item-id tag-id)))

(defn get-item-tags
  "Get all tags of a task"
  [item-id]
  (let [^drift/AppDatabase database (db/get-database)
        tags-dao (.-tagsDao database)]
    (.getItemTags tags-dao item-id)))

(defn get-items-by-tag
  "Get all tasks by tag"
  [tag-id]
  (let [^drift/AppDatabase database (db/get-database)
        tags-dao (.-tagsDao database)]
    (.getItemsByTag tags-dao tag-id)))

(defn get-items-by-tags
  "Get all tasks that have any of the specified tags (OR logic)"
  [tag-ids]
  (if (empty? tag-ids)
    (dart-core/Future.value [])
    (let [^drift/AppDatabase database (db/get-database)
          tags-dao (.-tagsDao database)]
      (.getItemsByTags tags-dao tag-ids))))

(defn get-items-by-all-tags
  "Get all tasks that have all of the specified tags (AND logic)"
  [tag-ids]
  (if (empty? tag-ids)
    (dart-core/Future.value [])
    (let [^drift/AppDatabase database (db/get-database)
          tags-dao (.-tagsDao database)]
      (.getItemsByAllTags tags-dao tag-ids))))

(defn refresh-tagged-items!
  "Refresh items filtered by tag(s) and write to app-state"
  [tag-ids filter-mode]
  (state/set-tags-loading! true)
  (let [query-fn (case filter-mode
                  :or get-items-by-tags
                  :and get-items-by-all-tags
                  get-items-by-tags)]
    (-> (query-fn tag-ids)
        (.then (fn [items]
                (state/set-tagged-items! items)
                (state/set-tags-loading! false)
                items))
        (.catchError (fn [e]
                     (toast/handle-error-global e "Тагтай ажлыг шинэчлэхэд алдаа гарлаа")
                     (state/set-tagged-items! [])
                     (state/set-tags-loading! false))))))

;; =============================================================================
;; Batch operations
;; =============================================================================

(defn batch-add-tag-to-items
  "Batch add tag to multiple tasks"
  [task-ids tag-id]
  (if (empty? task-ids)
    (dart-core/Future.value 0)
    (let [add-promises (map (fn [task-id]
                             (-> (add-tag-to-item task-id tag-id)
                                 (.then (fn [_] task-id))
                                 (.catchError (fn [error]
                                               (dart-core/print (str "Error adding tag to task " task-id ": " error))
                                               nil))))
                           task-ids)]
      (-> (dart-core/Future.wait add-promises)
          (.then (fn [results]
                   (let [successful-count (count (filter some? results))]
                     successful-count)))
          (.catchError (fn [error]
                        (toast/handle-error-global error "Тагийг бөөнөөр нэмэхэд алдаа гарлаа")
                        0))))))

