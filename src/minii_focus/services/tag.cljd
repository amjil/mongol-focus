(ns minii-focus.services.tag
  "Tag management service"
  (:require
   ["dart:core" :as dart-core]
   ["package:drift/drift.dart" :as d]
   ["package:cljd_mongol_focus/database/database.dart" :as drift]
   [clojure.set :as set]
   [minii-focus.services.database :as db]
   [minii-focus.states.app-state :as state]
   [minii-focus.utils.ids :as ids]))

;; =============================================================================
;; Tag CRUD operations
;; =============================================================================

(defn create-tag
  "Create tag"
  [{:keys [name parent-id]}]
  (let [^drift/AppDatabase database (db/get-database)
        tag-id (ids/generate-id)
        companion (drift/TagsCompanion.insert
                   .id tag-id
                   .name name
                   .parentId (when parent-id (d/Value parent-id)))]
    (.insert
     (.into database (.-tags database))
     companion)
    tag-id))

(defn update-tag
  "Update tag"
  [id {:keys [name parent-id]}]
  (let [^drift/AppDatabase database (db/get-database)
        query (doto (.update database (.-tags database))
                (.where (fn [^drift/Tags tbl] (.equals (.-id tbl) id))))
        companion (drift/TagsCompanion.
                   .name (when name (d/Value name))
                   .parentId (when parent-id (d/Value parent-id)))]
    (.write query companion)))

(defn delete-tag
  "Delete tag (also deletes associations)"
  [id]
  (let [^drift/AppDatabase database (db/get-database)]
    ;; First delete associations
    (.go
     (doto (.delete database (.-itemTags database))
       (.where (fn [^drift/ItemTags tbl] (.equals (.-tagId tbl) id)))))
    ;; Then delete tag
    (.go
     (doto (.delete database (.-tags database))
       (.where (fn [^drift/Tags tbl] (.equals (.-id tbl) id)))))))

(defn get-tag-by-id
  "Get tag by ID"
  [id]
  (let [^drift/AppDatabase database (db/get-database)]
    (.getSingleOrNull
     (doto (.select database (.-tags database))
       (.where (fn [^drift/Tags tbl] (.equals (.-id tbl) id)))))))

(defn get-all-tags
  "Get all tags"
  []
  (let [^drift/AppDatabase database (db/get-database)]
    (.get
     (doto (.select database (.-tags database))))))

;; =============================================================================
;; Page data loading/refresh (side effects in service)
;; =============================================================================

(defn refresh-tags!
  "Refresh tag list and write to app-state"
  []
  (state/set-tags-loading! true)
  (-> (get-all-tags)
      (.then (fn [rows]
               (state/set-tags! rows)
               (state/set-tags-loading! false)
               rows))
      (.catchError (fn [e]
                     (dart-core/print (str "Error refreshing tags: " e))
                     (state/set-tags-loading! false)))))

(defn get-tags-by-parent
  "Get all child tags of specified parent tag"
  [parent-id]
  (let [^drift/AppDatabase database (db/get-database)]
    (.get
     (doto (.select database (.-tags database))
       (.where (fn [^drift/Tags tbl] (.equals (.-parentId tbl) parent-id)))))))

;; =============================================================================
;; Tag and task associations
;; =============================================================================

(defn add-tag-to-item
  "Add tag to task"
  [item-id tag-id]
  (let [^drift/AppDatabase database (db/get-database)
        companion (drift/ItemTagsCompanion.insert
                   .itemId item-id
                   .tagId tag-id)]
    (.insert
     (.into database (.-itemTags database))
     companion)))

(defn remove-tag-from-item
  "Remove tag from task"
  [item-id tag-id]
  (let [^drift/AppDatabase database (db/get-database)]
    (.go
     (doto (.delete database (.-itemTags database))
       (.where (fn [^drift/ItemTags tbl]
                 (and (.equals (.-itemId tbl) item-id)
                      (.equals (.-tagId tbl) tag-id))))))))

(defn get-item-tags
  "Get all tags of a task"
  [item-id]
  (let [^drift/AppDatabase database (db/get-database)]
    (.get
     (doto (.select database (.-itemTags database))
       (.where (fn [^drift/ItemTags tbl] (.equals (.-itemId tbl) item-id)))))))

(defn get-items-by-tag
  "Get all tasks by tag"
  [tag-id]
  (let [^drift/AppDatabase database (db/get-database)]
    (.get
     (doto (.select database (.-items database))
       (.join [(fn [items item-tags]
                 (and (.equals (.-id items) (.-itemId item-tags))
                      (.equals (.-tagId item-tags) tag-id)))])))))

(defn get-items-by-tags
  "Get all tasks that have any of the specified tags (OR logic)"
  [tag-ids]
  (if (empty? tag-ids)
    (dart-core/Future.value [])
    (let [^drift/AppDatabase database (db/get-database)]
      (.get
       (doto (.select database (.-items database))
         (.join [(fn [items item-tags]
                   (and (.equals (.-id items) (.-itemId item-tags))
                        (.isIn (.-tagId item-tags) tag-ids)))]))))))

(defn get-items-by-all-tags
  "Get all tasks that have all of the specified tags (AND logic)"
  [tag-ids]
  (if (empty? tag-ids)
    (dart-core/Future.value [])
    (let [^drift/AppDatabase database (db/get-database)
          ;; Get items for each tag separately, then find intersection
          tag-queries (map (fn [tag-id]
                           (.get
                            (doto (.select database (.-items database))
                              (.join [(fn [items item-tags]
                                        (and (.equals (.-id items) (.-itemId item-tags))
                                             (.equals (.-tagId item-tags) tag-id)))]))))
                         tag-ids)]
      (-> (dart-core/Future.wait tag-queries)
          (.then (fn [results]
                  ;; Find intersection of all tag results
                  (if (empty? results)
                    []
                    (let [id-sets (map (fn [items] (set (map (fn [item] (.-id item)) items))) results)
                          common-ids (reduce (fn [acc s] (set/intersection acc s)) (first id-sets) (rest id-sets))
                          all-items (reduce concat results)]
                      (filter (fn [item] (contains? common-ids (.-id item))) all-items)))))))))

(defn refresh-tagged-items!
  "Refresh items filtered by tag(s) and write to app-state"
  [tag-ids filter-mode]
  (state/set-tags-loading! true)
  (let [query-fn (case filter-mode
                  :or get-items-by-tags
                  :and get-items-by-all-tags
                  get-items-by-tags)]
    (-> (query-fn tag-ids)
        (.then (fn [items]
                (state/set-tagged-items! items)
                (state/set-tags-loading! false)
                items))
        (.catchError (fn [e]
                     (dart-core/print (str "Error refreshing tagged items: " e))
                     (state/set-tagged-items! [])
                     (state/set-tags-loading! false))))))

