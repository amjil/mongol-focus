(ns minii-focus.services.item-tree
  "ItemTree management service - task hierarchy relationship management"
  (:require
   ["dart:core" :as dart-core]
   ["package:drift/drift.dart" :as d]
   ;; Corresponds to package name `cljd_mongol_focus` in pubspec.yaml
   ["package:cljd_mongol_focus/database/database.dart" :as drift]
   [minii-focus.services.database :as db]
   [minii-focus.services.task-dependencies :as dep-svc]))

;; =============================================================================
;; ItemTree CRUD operations
;; =============================================================================

(defn create-item-tree-relation
  "Create parent-child relationship"
  [parent-id child-id position]
  (let [^drift/AppDatabase database (db/get-database)
        companion (drift/ItemTreeCompanion.insert
                   .parentId parent-id
                   .childId child-id
                   .position position)]
    (.insert
     (.into database (.-itemTree database))
     companion)))

(defn delete-item-tree-relation
  "Delete parent-child relationship"
  [parent-id child-id]
  (let [^drift/AppDatabase database (db/get-database)]
    (.go
     (doto (.delete database (.-itemTree database))
       (.where (fn [^drift/ItemTree tbl]
                 (and (.equals (.-parentId tbl) parent-id)
                      (.equals (.-childId tbl) child-id))))))))

(defn update-item-position
  "Update task position among siblings"
  [parent-id child-id new-position]
  (let [^drift/AppDatabase database (db/get-database)
        query (doto (.update database (.-itemTree database))
                (.where (fn [^drift/ItemTree tbl]
                          (and (.equals (.-parentId tbl) parent-id)
                               (.equals (.-childId tbl) child-id)))))
        companion (drift/ItemTreeCompanion.
                   .position (d/Value new-position))]
    (.write query companion)))

;; =============================================================================
;; Query operations
;; =============================================================================

(defn get-children
  "Get all child tasks of specified parent task"
  [parent-id]
  (let [^drift/AppDatabase database (db/get-database)]
    (.get
     (doto (.select database (.-itemTree database))
       (.where (fn [^drift/ItemTree tbl] (.equals (.-parentId tbl) parent-id)))
       (.orderBy [(fn [tbl] (d/OrderingTerm.asc (.-position tbl)))])))))

(defn get-children-with-items
  "Get child tasks of parent task and their item records, sorted by position"
  [parent-id]
  (let [^drift/AppDatabase database (db/get-database)]
    (-> (get-children parent-id)
        (.then (fn [relations]
                 (let [child-ids (map (fn [rel] (.-childId rel)) relations)]
                   (if (empty? child-ids)
                     []
                     (-> (doto (.select database (.-items database))
                           (.where (fn [^drift/Items tbl] (.isIn (.-id tbl) child-ids))))
                         (.get)
                         (.then (fn [items]
                                  (let [pos-map (into {} (map (fn [rel] [(.-childId rel) (.-position rel)]) relations))]
                                    (->> items
                                         (sort-by (fn [it] (get pos-map (.-id it) 0)))
                                         (map (fn [it] {:item it
                                                        :position (get pos-map (.-id it))}))))))))))))))

(defn get-parent
  "Get parent task of specified task"
  [child-id]
  (let [^drift/AppDatabase database (db/get-database)]
    (.getSingleOrNull
     (doto (.select database (.-itemTree database))
       (.where (fn [^drift/ItemTree tbl] (.equals (.-childId tbl) child-id)))))))

(defn get-task-hierarchy
  "Get complete hierarchy structure of task (recursive)"
  [task-id]
  (let [^drift/AppDatabase database (db/get-database)
        children (get-children task-id)]
    (-> children
        (.then (fn [child-relations]
                 (let [child-ids (map (fn [rel] (.-childId rel)) child-relations)]
                   (if (empty? child-ids)
                     []
                     (-> (doto (.select database (.-items database))
                           (.where (fn [^drift/Items tbl]
                                     (.isIn (.-id tbl) child-ids))))
                         (.get)
                         (.then (fn [child-items]
                                  ;; Recursively get children of each child task
                                  (-> (dart-core/Future.wait
                                       (map (fn [item]
                                              (get-task-hierarchy (.-id item)))
                                            child-items))
                                      (.then (fn [nested-hierarchies]
                                               (map (fn [item hierarchy]
                                                      {:item item
                                                       :children hierarchy})
                                                    child-items
                                                    nested-hierarchies))))))))))))))

(defn is-task-blocked?
  "Check if task is blocked by parent task, sequential project rules, or dependencies (returns Future<bool>)"
  [task-id]
  (let [parent-relation (get-parent task-id)
        dependency-check (dep-svc/has-uncompleted-dependencies? task-id)]
    (-> (dart-core/Future.wait [parent-relation dependency-check])
        (.then (fn [[parent-rel has-uncompleted-deps?]]
                 ;; Check if blocked by dependencies first
                 (if has-uncompleted-deps?
                   true
                   ;; Then check parent relationship
                   (if parent-rel
                     (let [^drift/AppDatabase database (db/get-database)
                           parent-id (.-parentId parent-rel)]
                       (-> (.getSingleOrNull
                            (doto (.select database (.-items database))
                              (.where (fn [^drift/Items tbl] (.equals (.-id tbl) parent-id)))))
                           (.then (fn [parent-item]
                                    (if parent-item
                                      ;; Check if parent is completed
                                      (if (= (.-status parent-item) "completed")
                                        false
                                        ;; Check sequential project rules
                                        (let [project-type (.-projectType parent-item)]
                                          (if (= project-type "sequential")
                                            ;; For sequential projects, check if previous sibling is completed
                                            (-> (get-children parent-id)
                                                (.then (fn [siblings]
                                                        (let [current-rel (first (filter (fn [rel] (= (.-childId rel) task-id)) siblings))
                                                              current-pos (if current-rel (.-position current-rel) -1)
                                                              prev-siblings (filter (fn [rel] (< (.-position rel) current-pos)) siblings)]
                                                          (if (empty? prev-siblings)
                                                            ;; First task, not blocked by siblings
                                                            false
                                                            ;; Check if all previous siblings are completed
                                                            (let [prev-ids (map (fn [rel] (.-childId rel)) prev-siblings)]
                                                              (-> (doto (.select database (.-items database))
                                                                    (.where (fn [^drift/Items tbl] (.isIn (.-id tbl) prev-ids))))
                                                                  (.get)
                                                                  (.then (fn [prev-items]
                                                                           (not (every? (fn [item] (= (.-status item) "completed")) prev-items)))))))))))
                                            ;; For parallel projects or no project type, only check parent status
                                            true)))
                                      false))))
                     false))))))))

(defn check-tasks-blocked-status
  "Check blocked status for multiple tasks, returns map of task-id -> blocked?"
  [task-ids]
  (let [checks (map (fn [task-id]
                     (-> (is-task-blocked? task-id)
                         (.then (fn [blocked?] [task-id blocked?]))))
                   task-ids)]
    (-> (dart-core/Future.wait checks)
        (.then (fn [results]
                (into {} results))))))

;; =============================================================================
;; Hierarchy operations
;; =============================================================================

(defn move-task
  "Move task under new parent task"
  [task-id new-parent-id position]
  (let [old-parent (get-parent task-id)]
    (-> old-parent
        (.then (fn [old-parent-rel]
                 ;; Delete old relationship
                 (when old-parent-rel
                   (delete-item-tree-relation (.-parentId old-parent-rel) task-id))
                 ;; Create new relationship
                 (create-item-tree-relation new-parent-id task-id position))))))

(defn reorder-siblings
  "Reorder sibling tasks"
  [parent-id child-ids]
  (let [updates (map-indexed (fn [index child-id]
                               (update-item-position parent-id child-id index))
                             child-ids)]
    (dart-core/Future.wait updates)))

(defn set-parent-task
  "Set or change parent task for a task. If new-parent-id is nil, remove parent relationship."
  [task-id new-parent-id]
  (let [old-parent (get-parent task-id)]
    (-> old-parent
        (.then (fn [old-parent-rel]
                 ;; Delete old relationship if exists
                 (when old-parent-rel
                   (delete-item-tree-relation (.-parentId old-parent-rel) task-id))
                 ;; Create new relationship if new-parent-id is provided
                 (if new-parent-id
                   (do
                     ;; Get current children count of new parent to determine position
                     (-> (get-children new-parent-id)
                         (.then (fn [children]
                                 (let [position (count children)]
                                   (create-item-tree-relation new-parent-id task-id position)))))
                     (dart-core/Future.value nil))
                   (dart-core/Future.value nil)))))))

(defn remove-parent-task
  "Remove parent relationship for a task"
  [task-id]
  (let [old-parent (get-parent task-id)]
    (-> old-parent
        (.then (fn [old-parent-rel]
                 (if old-parent-rel
                   (delete-item-tree-relation (.-parentId old-parent-rel) task-id)
                   (dart-core/Future.value nil)))))))

