(ns minii-focus.core.dao.perspective
  "Perspective Query System Wrapper
  
  Perspective = A set of composable query constraints
  
  It answers:
  \"What perspective am I currently viewing Task / Forecast from?\"
  
  Usage example:
  (query-by-perspective!
   db
   {:entity :task
    :filters [{:field :status :op := :value 1}
              {:field :priority :op :>= :value 2}]
    :order-by [{:field :due-at :dir :asc}]
    :limit 20})"
  (:require
   ["package:cljd_mongol_focus/db/bridge/perspective_query_bridge.dart" :as bridge]))

(defn query-by-perspective!
  "Query entities by Perspective
  
  Parameters:
  - db: AppDatabase instance
  - perspective: Perspective map
    {:entity :task
     :filters [{:field :status :op := :value 1}
               {:field :priority :op :>= :value 2}]
     :order-by [{:field :due-at :dir :asc}]
     :limit 20}
  
  Returns: Future<List<map>>
  
  Notes:
  - cljd uses kebab-case (e.g., :due-at), Dart automatically converts to camelCase (dueAt)
  - Operators: =, !=, <, <=, >, >=, like, in, between
  - between operator's value should be a vector with two elements: [start, end]
  - Sort direction: :asc or :desc"
  [db perspective]
  (let [entity (:entity perspective)
        _ (when (nil? entity)
            (throw (ex-info "perspective :entity cannot be nil"
                            {:perspective perspective
                             :entity entity
                             :perspective-keys (keys perspective)})))
        bridge-instance (new bridge/PerspectiveQueryBridge db)
        ;; Convert perspective map to Dart format with string keys
        ;; ClojureDart keyword keys need to be explicitly converted to string keys for Dart
        dart-perspective (cond-> {"entity" (name entity)}
                            (:filters perspective)
                            (assoc "filters"
                                   (mapv (fn [f]
                                           {"field" (name (:field f))
                                            "op" (name (:op f))
                                            "value" (let [v (:value f)]
                                                     (cond
                                                       (keyword? v) (name v)
                                                       :else v))})
                                         (:filters perspective)))
                            
                            (:order-by perspective)
                            (assoc "orderBy"
                                   (mapv (fn [o]
                                           {"field" (name (:field o))
                                            "dir" (name (:dir o))})
                                         (:order-by perspective)))
                            
                            (:limit perspective)
                            (assoc "limit" (:limit perspective)))
        _ (when (nil? (get dart-perspective "entity"))
            (throw (ex-info "dart-perspective entity cannot be nil after conversion"
                            {:original-perspective perspective
                             :dart-perspective dart-perspective
                             :entity entity})))]
    (try
      (.queryByPerspective bridge-instance dart-perspective)
      (catch Exception e
        (throw (ex-info "Failed to query by perspective"
                        {:error (str e)
                         :perspective perspective
                         :dart-perspective dart-perspective
                         :entity entity}
                        e))))))

