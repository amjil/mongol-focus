(ns minii-focus.core.infra.bridge
  "ClojureDart ↔ Dart Bridge Utility Layer
   
   Provides utility functions like dart/call and dart/new for calling Dart code.
   
   Type conventions:
   - map → Companion
   - string → String
   - int → int
   - nil → null
   - vector → JSON string"
  (:require
   [clojure.string :as str]
   ["package:drift/drift.dart" :as drift]
   ["package:cljd_mongol_focus/db/bridge/value_helpers.dart" :as value-helpers]))

(defn camel-case
  "Convert kebab-case keyword to camelCase string
   
   Examples:
   (camel-case :entity-type) => \"entityType\"
   (camel-case :id) => \"id\""
  [k]
  (if (keyword? k)
    (let [s (name k)
          parts (str/split s #"-")]
      (if (= 1 (count parts))
        s
        (str (first parts)
             (apply str (map str/capitalize (rest parts))))))
    (str k)))

(defn dart-call
  "Call Dart function
  
  Example:
   (dart-call bridge/insertTimelineEvent dao-bridge companion)"
  [dart-fn & args]
  (apply dart-fn args))

(defn dart-new
  "Create Dart Companion object
  
  Example:
   (dart-new TimelineEventsCompanion {:id id :timestamp ts :entity-type \"task\"})
  
  Parameter map keys are automatically converted to camelCase (e.g., :entity-type → entityType)
  
  Note: companion-class should be an actual Dart class, e.g., app-db/TimelineEventsCompanion"
  [companion-class params]
  (let [dart-params (reduce-kv
                     (fn [m k v]
                       (assoc m (name (camel-case k)) v))
                     {}
                     params)
        ;; In ClojureDart, constructors with named parameters can be called
        ;; by converting the map to keyword arguments using apply
        args (mapcat (fn [[k v]] [(keyword k) v]) dart-params)]
    (apply companion-class args)))

(defn dart-value [v]
  (drift/Value v))

(defn dart-value-string
  "Create Value<String> for string values"
  [v]
  ;; Use Dart helper function to ensure correct type
  (value-helpers/valueString (str v)))

(defn dart-value-int
  "Create Value<int> for int values"
  [v]
  ;; Use Dart helper function to ensure correct type
  (value-helpers/valueInt (int v)))

(defn dart-value-string-nullable
  "Create Value<String?> for nullable string values"
  [v]
  ;; Use Dart helper function to ensure correct type
  (value-helpers/valueStringNullable (if v (str v) nil)))

(defn dart-value-int-nullable
  "Create Value<int?> for nullable int values"
  [v]
  ;; Use Dart helper function to ensure correct type
  (value-helpers/valueIntNullable (if v (int v) nil)))

(defn absent-value []
  (drift/Value. nil))
