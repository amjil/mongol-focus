(ns minii-focus.core.infra.bridge
  "ClojureDart ↔ Dart Bridge Utility Layer
   
   Provides utility functions like dart/call and dart/new for calling Dart code.
   
   Type conventions:
   - map → Companion
   - string → String
   - int → int
   - nil → null
   - vector → JSON string"
  (:require
   [clojure.string :as str]
   ["package:drift/drift.dart" :as drift]
   ["package:cljd_mongol_focus/db/bridge/value_helpers.dart" :as value-helpers]))

(defn camel-case
  "Convert kebab-case keyword to camelCase string
   
   Examples:
   (camel-case :entity-type) => \"entityType\"
   (camel-case :id) => \"id\""
  [k]
  (if (keyword? k)
    (let [s (name k)
          parts (str/split s #"-")]
      (if (= 1 (count parts))
        s
        (str (first parts)
             (apply str (map str/capitalize (rest parts))))))
    (str k)))

(defn dart-call
  "Call Dart function
  
  Example:
   (dart-call bridge/insertTimelineEvent dao-bridge companion)"
  [dart-fn & args]
  (apply dart-fn args))

(defn dart-new
  "Create Dart Companion object using named constructor
  
  Example:
   (dart-new TasksCompanion.insert {:id id :title title :createdAt now})
  
  Parameter map keys are automatically converted to camelCase (e.g., :entity-type → entityType)
  
  Note: In ClojureDart, named constructors with named parameters cannot use 'apply'.
  This function uses a workaround by calling the constructor with keyword arguments directly.
  
  companion-constructor should be a named constructor, e.g., app-db/TasksCompanion.insert"
  [companion-constructor params]
  ;; Note: ClojureDart cannot use 'apply' for Dart named parameters.
  ;; This function is kept for backward compatibility but will throw an error.
  ;; For new code, use direct constructor calls with named parameters.
  (throw (ex-info "dart-new cannot dynamically call named constructors in ClojureDart. Please use direct constructor calls."
                  {:constructor companion-constructor
                   :params params
                   :suggestion "Use direct constructor call like: (TasksCompanion.insert :id id :title title ...)"})))

(defn dart-value [v]
  (drift/Value v))

(defn dart-value-string
  "Create Value<String> for string values"
  [v]
  ;; Use Dart helper function to ensure correct type
  (value-helpers/valueString (str v)))

(defn dart-value-int
  "Create Value<int> for int values"
  [v]
  ;; Use Dart helper function to ensure correct type
  (value-helpers/valueInt (int v)))

(defn dart-value-string-nullable
  "Create Value<String?> for nullable string values"
  [v]
  ;; Use Dart helper function to ensure correct type
  (value-helpers/valueStringNullable (if v (str v) nil)))

(defn dart-value-int-nullable
  "Create Value<int?> for nullable int values"
  [v]
  ;; Use Dart helper function to ensure correct type
  (value-helpers/valueIntNullable (if v (int v) nil)))

(defn dart-value-bool
  "Create Value<bool> for boolean values"
  [v]
  ;; Use Dart helper function to ensure correct type
  (value-helpers/valueBool (boolean v)))

(defn dart-value-bool-absent
  "Create Value<bool> that is absent (for optional boolean fields)"
  []
  (value-helpers/valueBoolAbsent))

(defn dart-value-int-absent
  "Create Value<int> that is absent (for optional int fields)"
  []
  (value-helpers/valueIntAbsent))

(defn absent-value []
  (drift/Value. nil))
