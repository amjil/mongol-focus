(ns minii-focus.core.event.executor
  "Event â†’ Drift Transaction Executor
  
  This is the core execution layer of the Event system, responsible for:
  1. Receiving validated Events
  2. Executing Handler in transaction (database operations)
  3. Recording Event to TimelineEvents
  4. Ensuring atomicity (behavior + Event recording)
  
  Design principles:
  - All operations execute in transactions
  - Handler performs database operations
  - Events are recorded to TimelineEvents
  - Any failure will rollback the entire transaction"
  (:require
   [clojure.string :as str]
   [minii-focus.core.event.validator :as validator]
   [minii-focus.core.event.handler :as handler]
   [minii-focus.core.db.timeline :as timeline]
   [minii-focus.core.db.tx :as tx]
   [minii-focus.core.event.definitions :as event-def]
   [minii-focus.core.utils.logger :as logger]
   ["dart:core" :as dart-core]))

;; ============================================================================
;; Helper Functions
;; ============================================================================

(defn extract-entity-info
  "Extract entity-type and entity-id from Event
  
  Parameters:
  - event: {:type keyword|string :payload map}
  
  Returns: {:entity-type string :entity-id string?}"
  [{:keys [type payload]}]
  (let [;; Convert keyword to string: :task/create -> "task/create"
        ;; If already string, keep as is
        type-str (if (keyword? type)
                   (if-let [ns (namespace type)]
                     (str ns "/" (name type))
                     (name type))
                   type)
        entity-type (case (first (str/split type-str #"/"))
                      "task" "task"
                      "project" "project"
                      "perspective" "perspective"
                      "forecast" "forecast"
                      "focus" "focus"
                      "review" "review"
                      "system" "system"
                      "unknown")
        entity-id (case entity-type
                    "task" (:task-id payload)
                    "project" (:project-id payload)
                    "perspective" (:perspective-id payload)
                    "forecast" (:forecast-id payload)
                    "focus" (:session-id payload)
                    "review" (:review-id payload)
                    nil)]
    {:entity-type entity-type
     :entity-id entity-id}))

(defn extract-title
  "Extract title from Event payload (for Timeline display)
  
  Parameters:
  - event: {:type keyword|string :payload map}
  
  Returns: string"
  [{:keys [type payload]}]
  (or (:title payload)
      (:name payload)
      (let [type-str (if (keyword? type)
                       (if-let [ns (namespace type)]
                         (str ns "/" (name type))
                         (name type))
                       type)]
        (str type-str " event"))))

(defn extract-duration
  "Extract duration from payload (write to TimelineEvents.duration)
  
  Currently only used for Focus completion events:
  - :duration-minutes (int)"
  [{:keys [payload]}]
  (let [v (or (:duration-minutes payload)
              (:duration payload))]
    (when (some? v)
      (int v))))

(defn event-to-timeline-event
  "Convert Event to TimelineEvent format
  
  Parameters:
  - event: Complete Event map (contains id, type, payload, created-at, source)
  
  Returns: TimelineEvent map"
  [event]
  (let [{:keys [id type payload created-at]} event
        ;; Convert keyword to string: :task/create -> "task/create"
        ;; If already string, keep as is
        type-str (if (keyword? type)
                   (if-let [ns (namespace type)]
                     (str ns "/" (name type))
                     (name type))
                   type)
        {:keys [entity-type entity-id]} (extract-entity-info event)
        title (extract-title event)
        duration (extract-duration event)
        payload-json (event-def/payload-to-json payload)]
    {:id id
     :timestamp created-at
     :type type-str
     :entity-type entity-type
     :entity-id entity-id
     :title title
     :duration duration
     :perspectives nil
     :payload payload-json}))

;; ============================================================================
;; Event Executor
;; ============================================================================

(defn execute-event!
  "Execute Event (transaction)
  
  Parameters:
  - ctx: {:db AppDatabase :dao DaoBridge}
  - event: Complete Event map (already validated)
  
  Returns: Future<void>
  
  Flow:
  1. Validate Event (if not already validated)
  2. Execute in transaction:
     a. Handler performs database operations
     b. Record Event to TimelineEvents
  3. Ensure atomicity
  
  Note:
  - Event must contain all required fields (id, type, payload, created-at, source)
  - All operations execute in transaction, failures will rollback"
  [ctx event]
  (let [{:keys [db dao]} ctx
        ;; Ensure Event is validated
        validated-event (validator/validate-event! event)
        {:keys [type payload]} validated-event
        ;; Convert keyword to string: :task/create -> "task/create"
        ;; If already string, keep as is
        type-str (if (keyword? type)
                   (if-let [ns (namespace type)]
                     (str ns "/" (name type))
                     (name type))
                   type)
        timeline-event (event-to-timeline-event validated-event)]
    (logger/debug "event/executor" "Executing event" {:original-type (:type event)
                                                       :validated-type type
                                                       :type-str type-str
                                                       :event-id (:id validated-event)})
    ;; Execute in transaction:
    ;; 1. Handler processes business logic (database operations)
    ;; 2. Record Event to TimelineEvents
    (tx/with-tx db
      (fn []
        ;; Execute business logic first
        (let [result (-> (handler/handle-event! ctx {:type type-str :payload payload})
                         (.then (fn [_]
                                 ;; Then record Event
                                 (timeline/insert-event! dao timeline-event)))
                         (.catchError (fn [error]
                                       (logger/error "event/executor" "Error executing event" {:error (str error)
                                                                                                :event-id (:id validated-event)
                                                                                                :event-type type-str})
                                       (throw error))))]
          result)))))

(defn execute-event-with-validation!
  "Execute Event (with validation)
  
  Parameters:
  - ctx: {:db AppDatabase :dao DaoBridge}
  - event: Event map (may be incomplete, will be auto-filled)
  
  Returns: Future<void>
  
  This is the recommended usage, will automatically:
  1. Fill missing fields (id, created-at, source)
  2. Validate Event
  3. Execute Event
  
  Usage example:
  (execute-event-with-validation! ctx
                                   {:type :task/create
                                    :payload {:title \"New Task\"}
                                    :source :ui})"
  [ctx event]
  (let [{:keys [type payload source]} event
        ;; Automatically fill missing base fields
        event-id (or (:id event)
                     (str "event-" (-> (dart-core/DateTime.now) (.-millisecondsSinceEpoch)) "-" (rand-int 10000)))
        created-at (or (:created-at event)
                       (int (/ (-> (dart-core/DateTime.now) (.-millisecondsSinceEpoch)) 1000)))
        source (or source :ui)
        ;; Build complete event
        full-event {:id event-id
                    :type type
                    :payload payload
                    :created-at created-at
                    :source source}]
    ;; Execute Event (will validate internally)
    (execute-event! ctx full-event)))

