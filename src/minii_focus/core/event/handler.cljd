(ns minii-focus.core.event.handler
  "Event Handler
  Converts Events to database operations (transactions).
  This is the core layer: Event → Transaction → Drift DAO.
  Each Event type has a corresponding handler function that performs the corresponding database operations."
  (:require
   [minii-focus.core.event.validator :as validator]
   [minii-focus.core.event.definitions :as event-def]
   [minii-focus.core.db.task :as task]
   [minii-focus.core.db.task-tags :as task-tags]
   [minii-focus.core.db.timeline :as timeline]
   [minii-focus.core.db.tx :as tx]
   [clojure.string :as str]
   [minii-focus.core.db.project :as project]
   [minii-focus.core.db.perspective :as perspective]
   [minii-focus.core.db.forecast :as forecast]
   [minii-focus.core.db.review :as review]
   [minii-focus.core.domain.calibration.review-to-forecast :as calib]
   [minii-focus.core.infra.bridge :as bridge]
   [minii-focus.core.utils.time :as time]
   [minii-focus.core.utils.logger :as logger]
   ["package:cljd_mongol_focus/db/app_database.dart" :as app-db]
   ["package:cljd_mongol_focus/db/bridge/forecast_bridge.dart" :as forecast-bridge]
   ["dart:core" :as dart-core]
   ["dart:convert" :as json]))

;; ============================================================================
;; Forward Declarations
;; ============================================================================

(declare handle-event!)

;; ============================================================================
;; Helper Functions
;; ============================================================================

(defn- extract-entity-info
  "Extract entity-type and entity-id from Event (internal use, avoids circular dependencies)"
  [{:keys [type payload]}]
  (let [;; Convert keyword to string: :task/create -> "task/create"
        ;; If already string, keep as is
        type-str (if (keyword? type)
                   (if-let [ns (namespace type)]
                     (str ns "/" (name type))
                     (name type))
                   type)
        entity-type (case (first (str/split type-str #"/"))
                      "task" "task"
                      "project" "project"
                      "perspective" "perspective"
                      "forecast" "forecast"
                      "focus" "focus"
                      "review" "review"
                      "system" "system"
                      "unknown")
        entity-id (case entity-type
                    "task" (:task-id payload)
                    "project" (:project-id payload)
                    "perspective" (:perspective-id payload)
                    "forecast" (:forecast-id payload)
                    "focus" (:session-id payload)
                    "review" (:review-id payload)
                    nil)]
    {:entity-type entity-type
     :entity-id entity-id}))

(defn- extract-title
  "Extract title from Event payload (internal use)"
  [{:keys [type payload]}]
  (or (:title payload)
      (:name payload)
      (let [type-str (if (keyword? type)
                       (if-let [ns (namespace type)]
                         (str ns "/" (name type))
                         (name type))
                       type)]
        (str type-str " event"))))

(defn- extract-duration
  "Extract duration from payload (internal use)"
  [{:keys [payload]}]
  (let [v (or (:duration-minutes payload)
              (:duration payload))]
    (when (some? v)
      (int v))))

(defn- event-to-timeline-event
  "Convert Event to TimelineEvent format (internal use, avoids circular dependencies)"
  [event]
  (let [{:keys [id type payload created-at]} event
        ;; Convert keyword to string: :task/create -> "task/create"
        ;; If already string, keep as is
        type-str (if (keyword? type)
                   (if-let [ns (namespace type)]
                     (str ns "/" (name type))
                     (name type))
                   type)
        {:keys [entity-type entity-id]} (extract-entity-info event)
        title (extract-title event)
        duration (extract-duration event)
        payload-json (event-def/payload-to-json payload)]
    {:id id
     :timestamp created-at
     :type type-str
     :entity-type entity-type
     :entity-id entity-id
     :title title
     :duration duration
     :perspectives nil
     :payload payload-json}))

(defn- system-dispatch-inline!
  "System auto-dispatch Event (inline implementation, avoids circular dependencies)
  
  This is a function used internally by handler to trigger system events.
  Directly inlines executor logic to avoid compile-time circular dependencies."
  [ctx event]
  (let [{:keys [db dao]} ctx
        {:keys [type payload]} event
        ;; Automatically fill missing base fields
        event-id (or (:id event)
                     (str "event-" (-> (dart-core/DateTime.now) (.-millisecondsSinceEpoch)) "-" (rand-int 10000)))
        created-at (or (:created-at event)
                       (int (/ (-> (dart-core/DateTime.now) (.-millisecondsSinceEpoch)) 1000)))
        source :system
        ;; Build complete event
        full-event {:id event-id
                    :type type
                    :payload payload
                    :created-at created-at
                    :source source}
        ;; Validate event
        validated-event (validator/validate-event! full-event)
        {:keys [type payload]} validated-event
        ;; Convert keyword to string: :task/create -> "task/create"
        ;; If already string, keep as is
        type-str (if (keyword? type)
                   (if-let [ns (namespace type)]
                     (str ns "/" (name type))
                     (name type))
                   type)
        timeline-event (event-to-timeline-event validated-event)]
    ;; Execute in transaction:
    ;; 1. Handler processes business logic (database operations)
    ;; 2. Record Event to TimelineEvents
    (tx/with-tx db
      (fn []
        ;; Execute business logic first
        (-> (handle-event! ctx {:type type-str :payload payload})
            (.then (fn [_]
                    ;; Then record Event
                    (timeline/insert-event! dao timeline-event)))
            (.catchError (fn [error]
                          (dart-core/print (str "Error executing system event: " error))
                          (throw error))))))))

(defn generate-id
  "Generate ID
  
  Parameters:
  - prefix: string (e.g. \"task\", \"project\")
  
  Returns: string"
  [prefix]
  (str prefix "-" (-> (dart-core/DateTime.now) (.-millisecondsSinceEpoch))))

(defn json-encode
  "JSON encoding"
  [data]
  (json/jsonEncode data))

;; ============================================================================
;; Event Handlers
;; ============================================================================

(defn handle-task-create
  "Handle task/create Event
  
  Parameters:
  - ctx: {:db AppDatabase :dao DaoBridge}
  - payload: {:title string :note string? :source keyword :project-id string? :perspective-id string? :due-at int? :defer-at int? :tags [string]?}
  
  Returns: Future<void>"
  [ctx payload]
  (let [{:keys [dao]} ctx
        {:keys [title project-id perspective-id due-at defer-at tags]} payload
        task-id (generate-id "task")
        now (int (/ (-> (dart-core/DateTime.now) (.-millisecondsSinceEpoch)) 1000))
        perspectives-json (when perspective-id
                            (json-encode [perspective-id]))
        task-data {:id task-id
                   :title title
                   :project-id project-id
                   :perspectives perspectives-json
                   :created-at now
                   :due-at due-at
                   :defer-at defer-at}]
    (-> (task/insert-task! dao task-data)
        (.then (fn [_]
                 (if (and tags (seq tags))
                   (let [tag-futures (map #(task-tags/add-tag-to-task! dao task-id %) tags)]
                     (dart-core/Future.wait (vec tag-futures)))
                   (dart-core/Future.value nil)))))))

(defn handle-task-complete
  "Handle task/complete Event
  
  Parameters:
  - ctx: {:db AppDatabase :dao DaoBridge}
  - payload: {:task-id string}
  
  Returns: Future<void>"
  [ctx payload]
  (let [{:keys [dao]} ctx
        {:keys [task-id]} payload]
    (task/mark-completed! dao task-id)))

(defn handle-task-archive
  "Handle task/archive Event
  
  Parameters:
  - ctx: {:db AppDatabase :dao DaoBridge}
  - payload: {:task-id string}
  
  Returns: Future<void>
  
  Note: Current implementation marks as completed, can be extended to soft delete in the future"
  [ctx payload]
  (let [{:keys [dao]} ctx
        {:keys [task-id]} payload]
    ;; Temporarily use mark-completed, can be extended to soft delete in the future
    (task/mark-completed! dao task-id)))

(defn handle-task-assign-project
  "Handle task/assign-project Event
  
  Parameters:
  - ctx: {:db AppDatabase :dao DaoBridge}
  - payload: {:task-id string :project-id string}
  
  Returns: Future<void>"
  [ctx payload]
  (let [{:keys [dao]} ctx
        {:keys [task-id project-id]} payload
        updates (app-db/TasksCompanion
                 :projectId (bridge/dart-value-string-nullable project-id))]
    (task/update-task! dao task-id updates)))

(defn handle-task-assign-perspective
  "Handle task/assign-perspective Event
  
  Parameters:
  - ctx: {:db AppDatabase :dao DaoBridge}
  - payload: {:task-id string :perspective-id string}
  
  Returns: Future<void>
  
  Note: After binding perspective, will trigger Forecast auto-generation"
  [ctx payload]
  (let [{:keys [dao]} ctx
        {:keys [task-id perspective-id]} payload]
    ;; Get existing task first
    (-> (task/get-by-id dao task-id)
        (.then (fn [task]
                (if task
                  (let [existing-perspectives (.-perspectives task)
                        perspectives-list (if existing-perspectives
                                            (json/jsonDecode existing-perspectives)
                                            [])
                        already-has-perspective? (some #(= % perspective-id) perspectives-list)
                        new-perspectives-list (if already-has-perspective?
                                                perspectives-list
                                                (conj perspectives-list perspective-id))
                        perspectives-json (json-encode new-perspectives-list)
                        updates (app-db/TasksCompanion
                                 :perspectives (bridge/dart-value-string-nullable perspectives-json))]
                    (-> (task/update-task! dao task-id updates)
                        (.then (fn [_]
                                 ;; If this is a newly bound perspective, trigger Forecast auto-generation
                                 (if (not already-has-perspective?)
                                   (let [today-ts (int (/ (-> (dart-core/DateTime.now) (.-millisecondsSinceEpoch)) 1000))
                                         today-yyyymmdd (time/ts->yyyymmdd today-ts)]
                                     ;; Trigger Forecast auto-generation (system event)
                                     ;; Note: Use inline system-dispatch-inline! to avoid circular dependencies
                                     (system-dispatch-inline! ctx
                                                              {:type :forecast/auto-add
                                                               :payload {:task-id task-id
                                                                         :date today-yyyymmdd
                                                                         :rule (str "perspective-" perspective-id)}}))
                                   (dart-core/Future.value nil))))))
                  (do
                    (dart-core/print (str "Task not found: " task-id))
                    (dart-core/Future.value nil)))))
        (.catchError (fn [error]
                      (dart-core/print (str "Error assigning perspective: " error))
                      (throw error))))))

(defn handle-project-create
  "Handle project/create Event
  
  Parameters:
  - ctx: {:db AppDatabase :dao DaoBridge}
  - payload: {:name string :note string?}
  
  Returns: Future<void>"
  [ctx payload]
  (let [{:keys [dao]} ctx
        {:keys [name note]} payload
        project-id (generate-id "project")
        now (int (/ (-> (dart-core/DateTime.now) (.-millisecondsSinceEpoch)) 1000))
        project-data {:id project-id
                      :title name
                      :created-at now
                      :review-at nil
                      :completed false
                      :status "active"
                      :notes note}]
    (project/insert-project! dao project-data)))

(defn handle-project-rename
  "Handle project/rename Event
  
  Parameters:
  - ctx: {:db AppDatabase :dao DaoBridge}
  - payload: {:project-id string :name string}
  
  Returns: Future<void>"
  [ctx payload]
  (let [{:keys [dao]} ctx
        {:keys [project-id name]} payload]
    (project/update-title! dao project-id name)))

(defn handle-project-archive
  "Handle project/archive Event
  
  Parameters:
  - ctx: {:db AppDatabase :dao DaoBridge}
  - payload: {:project-id string}
  
  Returns: Future<void>"
  [ctx payload]
  (let [{:keys [dao]} ctx
        {:keys [project-id]} payload]
    ;; Archive project: set status to "archived"
    (project/update-status! dao project-id "archived")))

(defn handle-project-restore
  "Handle project/restore Event
  
  Parameters:
  - ctx: {:db AppDatabase :dao DaoBridge}
  - payload: {:project-id string}
  
  Returns: Future<void>"
  [ctx payload]
  (let [{:keys [dao]} ctx
        {:keys [project-id]} payload]
    ;; Restore project: set status to "active"
    (project/update-status! dao project-id "active")))

(defn handle-task-remove-project
  "Handle task/remove-project Event
  
  Parameters:
  - ctx: {:db AppDatabase :dao DaoBridge}
  - payload: {:task-id string}
  
  Returns: Future<void>"
  [ctx payload]
  (let [{:keys [dao]} ctx
        {:keys [task-id]} payload
        updates (app-db/TasksCompanion
                 :projectId (bridge/dart-value-string-nullable nil))]  ; Set to nil to remove
    (task/update-task! dao task-id updates)))

(defn handle-perspective-create
  "Handle perspective/create Event
  
  Parameters:
  - ctx: {:db AppDatabase :dao DaoBridge}
  - payload: {:name string :type string :rules map}
  
  Returns: Future<void>"
  [ctx payload]
  (let [{:keys [dao]} ctx
        {:keys [name rules]} payload
        perspective-id (generate-id "perspective")
        now (int (/ (-> (dart-core/DateTime.now) (.-millisecondsSinceEpoch)) 1000))
        rules-json (json-encode rules)
        perspective-data {:id perspective-id
                          :title name
                          :weight 0.5
                          :weight-history nil
                          :created-at now
                          :updated-at now
                          :rules rules-json}]
    ;; rules are stored in the rules field of the perspectives table
    (perspective/insert-perspective! dao perspective-data)))

(defn handle-perspective-update-rules
  "Handle perspective/update-rules Event
  
  Parameters:
  - ctx: {:db AppDatabase :dao DaoBridge}
  - payload: {:perspective-id string :rules map|string}
    - rules: Can be a map (needs JSON encoding) or already a JSON string (use directly)
  
  Returns: Future<void>"
  [ctx payload]
  (let [{:keys [dao]} ctx
        {:keys [perspective-id rules]} payload
        rules-type (if (string? rules) "string" "other")
        rules-preview (if (string? rules)
                       (if (> (count rules) 200)
                         (str (subs rules 0 200) "...")
                         rules)
                       (str rules))
        ;; If rules is already a string, use directly; otherwise encode to JSON
        rules-json (if (string? rules)
                    rules
                    (json-encode rules))
        now (int (/ (-> (dart-core/DateTime.now) (.-millisecondsSinceEpoch)) 1000))]
    (logger/info "event/handler" "Handling perspective/update-rules" {:perspective-id perspective-id
                                                                 :rules-type rules-type
                                                                 :rules-preview rules-preview
                                                                 :rules-length (if (string? rules) (count rules) nil)
                                                                 :final-json-length (count rules-json)
                                                                 :final-json-preview (if (> (count rules-json) 200)
                                                                                       (str (subs rules-json 0 200) "...")
                                                                                       rules-json)})
    (perspective/update-rules! dao perspective-id rules-json now)))

(defn handle-perspective-update-weight
  "Handle perspective/update-weight Event
  
  Parameters:
  - ctx: {:db AppDatabase :dao DaoBridge}
  - payload: {:perspective-id string :weight double}
  
  Returns: Future<void>"
  [ctx payload]
  (let [{:keys [dao]} ctx
        {:keys [perspective-id weight]} payload
        now (int (/ (-> (dart-core/DateTime.now) (.-millisecondsSinceEpoch)) 1000))]
    (perspective/update-weight! dao perspective-id weight now)))

(defn handle-task-remove-perspective
  "Handle task/remove-perspective Event
  
  Parameters:
  - ctx: {:db AppDatabase :dao DaoBridge}
  - payload: {:task-id string}
  
  Returns: Future<void>"
  [ctx payload]
  (let [{:keys [dao]} ctx
        {:keys [task-id]} payload
        ;; Get existing task first
        existing-task (-> (task/get-by-id dao task-id)
                          (.then (fn [task]
                                  (if task
                                    (let [existing-perspectives (.-perspectives task)
                                          _perspectives-list (if existing-perspectives
                                                              (json/jsonDecode existing-perspectives)
                                                              [])
                                          ;; Remove all perspectives (or can be extended to remove specific perspective)
                                          updates (app-db/TasksCompanion
                                                   :perspectives (bridge/dart-value-string-nullable nil))]
                                      (task/update-task! dao task-id updates))
                                    (dart-core/print (str "Task not found: " task-id)))))
                          (.catchError (fn [error]
                                        (dart-core/print (str "Error removing perspective: " error))
                                        (throw error))))]
    existing-task))

(defn handle-forecast-add
  "Handle forecast/add Event
  
  Parameters:
  - ctx: {:db AppDatabase :dao DaoBridge}
  - payload: {:task-id string :date int (yyyyMMdd)}
  
  Returns: Future<void>"
  [ctx payload]
  (let [{:keys [dao]} ctx
        {:keys [task-id date]} payload
        forecast-id (generate-id "forecast")
        now (-> (dart-core/DateTime.now) (.-millisecondsSinceEpoch))
        forecast-data {:id forecast-id
                       :task-id task-id
                       :scheduled-date date
                       :done false
                       :skipped false
                       :confidence 50
                       :source 1  ; 1 = manual
                       :created-at now}]
    (forecast/insert-forecast! dao forecast-data)))

(defn handle-forecast-remove
  "Handle forecast/remove Event
  
  Parameters:
  - ctx: {:db AppDatabase :dao DaoBridge}
  - payload: {:forecast-id string}
  
  Returns: Future<void>"
  [ctx payload]
  (let [{:keys [dao]} ctx
        {:keys [forecast-id]} payload]
    (forecast/delete-forecast! dao forecast-id)))

(defn handle-forecast-reschedule
  "Handle forecast/reschedule Event
  
  Parameters:
  - ctx: {:db AppDatabase :dao DaoBridge}
  - payload: {:forecast-id string :date int (yyyyMMdd)}
  
  Returns: Future<void>"
  [ctx payload]
  (let [{:keys [dao]} ctx
        {:keys [forecast-id date]} payload]
    (forecast/update-scheduled-date! dao forecast-id date)))

(defn handle-forecast-complete
  "Handle forecast/complete Event
  
  Parameters:
  - ctx: {:db AppDatabase :dao DaoBridge}
  - payload: {:forecast-id string}
  
  Returns: Future<void>"
  [ctx payload]
  (let [{:keys [dao]} ctx
        {:keys [forecast-id]} payload]
    (forecast/mark-done! dao forecast-id)))

(defn handle-focus-start
  "Handle focus/start Event
  
  Parameters:
  - ctx: {:db AppDatabase :dao DaoBridge}
  - payload: {:forecast-id string}
  
  Returns: Future<void>
  
  Note:
  - Current implementation is minimal version, only records Event
  - Can be extended to create focus-session table records in the future"
  [ctx _payload]
  (let [_ctx ctx]
    ;; Minimal implementation: only record Event, don't create additional session table
    ;; Event is already recorded to TimelineEvents, can be used for replay and statistics
    (dart-core/print "Focus started")
    (dart-core/Future.value nil)))

(defn handle-focus-pause
  "Handle focus/pause Event
  
  Parameters:
  - ctx: {:db AppDatabase :dao DaoBridge}
  - payload: {:session-id string}
  
  Returns: Future<void>
  
  Note:
  - Current implementation is minimal version, only records Event
  - Can be extended to update focus-session status in the future"
  [ctx _payload]
  (let [_ctx ctx]
    ;; Minimal implementation: only record Event
    (dart-core/print "Focus paused")
    (dart-core/Future.value nil)))

(defn handle-focus-complete
  "Handle focus/complete Event
  
  Parameters:
  - ctx: {:db AppDatabase :dao DaoBridge}
  - payload: {:session-id string}
  
  Returns: Future<void>
  
  Note:
  - Current implementation is minimal version, only records Event
  - Can be extended to update focus-session status and statistics in the future"
  [ctx _payload]
  (let [_ctx ctx]
    ;; Minimal implementation: only record Event
    ;; Event is already recorded to TimelineEvents, can be used for replay and statistics
    (dart-core/print "Focus completed")
    (dart-core/Future.value nil)))

(defn handle-focus-abort
  "Handle focus/abort Event
  
  Parameters:
  - ctx: {:db AppDatabase :dao DaoBridge}
  - payload: {:session-id string :reason string?}
  
  Returns: Future<void>
  
  Note:
  - Current implementation is minimal version, only records Event
  - Event is already recorded to TimelineEvents, can be used for replay and statistics
  - reason field is used to record abort reason (optional)"
  [ctx _payload]
  (let [_ctx ctx]
    ;; Minimal implementation: only record Event
    ;; Event is already recorded to TimelineEvents, can be used for replay and statistics
    (dart-core/print "Focus aborted")
    (dart-core/Future.value nil)))

(defn handle-review-submit
  "Handle review/submit Event
  
  Parameters:
  - ctx: {:db AppDatabase :dao DaoBridge}
  - payload: {:period map :stats map}
    - period: {:type :day|:week|:month :start int :end int}
    - stats: {:expected-count int :actual-count int :expected-duration int :actual-duration int :mood-score double :focus-score double}
  
  Returns: Future<void>"
  [ctx payload]
  (let [{:keys [dao]} ctx
        {:keys [period stats]} payload
        review-id (str "review-" (-> (dart-core/DateTime.now) (.-millisecondsSinceEpoch)))
        now (int (/ (-> (dart-core/DateTime.now) (.-millisecondsSinceEpoch)) 1000))
        review-data {:id review-id
                      :period-start (:start period)
                      :period-end (:end period)
                      :expected-count (or (:expected-count stats) 0)
                      :actual-count (or (:actual-count stats) 0)
                      :expected-duration (or (:expected-duration stats) 0)
                      :actual-duration (or (:actual-duration stats) 0)
                      :mood-score (or (:mood-score stats) 0.0)
                      :focus-score (or (:focus-score stats) 0.0)
                      :created-at now}]
    (review/insert-review! dao review-data)))

(defn handle-forecast-auto-adjust
  "Handle forecast/auto-adjust Event
  
  Parameters:
  - ctx: {:db AppDatabase :dao DaoBridge}
  - payload: {:rule string :affected vector :review-id string?}
  
  Returns: Future<void>
  
  Functionality:
  - Automatically adjust affected Forecasts based on Review data
  - rule: Calibration rule identifier (e.g. 'review-calibration')
  - affected: List of affected forecast-ids
  - review-id: Optional Review ID, if provided use that Review's data"
  [ctx payload]
  (let [{:keys [dao]} ctx
        {:keys [affected review-id]} payload]
    (if (empty? affected)
      ;; If no affected Forecasts, return directly
      (dart-core/Future.value nil)
      ;; Get latest Review data (if review-id provided, use that Review)
      (let [review-future (if review-id
                           (review/get-review dao review-id)
                           ;; Otherwise get latest Review
                           (-> (review/watch-all-reviews dao)
                               (.first)
                               (.then (fn [reviews]
                                       (if (and (seq reviews) (> (count reviews) 0))
                                         ;; Sort by creation time descending, take latest
                                         (let [sorted-reviews (sort (fn [a b]
                                                                     (compare (.-createdAt b) (.-createdAt a)))
                                                                   reviews)]
                                           (first sorted-reviews))
                                         nil)))))]
        (-> review-future
            (.then (fn [review-data]
                    (if review-data
                      ;; Have Review data, calibrate each affected Forecast
                      (let [review-map {:expected-count (.-expectedCount review-data)
                                       :actual-count (.-actualCount review-data)
                                       :expected-duration (.-expectedDuration review-data)
                                       :actual-duration (.-actualDuration review-data)
                                       :mood-score (.-moodScore review-data)
                                       :focus-score (.-focusScore review-data)}
                            ;; Get all affected Forecasts
                            forecast-futures (map (fn [forecast-id]
                                                   (forecast/get-by-id dao forecast-id))
                                                 affected)]
                        ;; Wait for all Forecasts to load
                        (-> (dart-core/Future.wait (vec forecast-futures))
                            (.then (fn [forecasts]
                                    ;; Apply calibration to each Forecast
                                    (let [calibration-futures
                                          (map (fn [forecast]
                                                (if forecast
                                                  ;; Get or create ForecastCalibration
                                                  (let [_calibration-id (str "calib-" (.-id forecast))
                                                        ;; Default values
                                                        default-target-count 10.0
                                                        default-target-duration 60.0
                                                        default-confidence 0.7
                                                        default-volatility 0.2
                                                        ;; Calibrate from Review data
                                                        calibrated (calib/calibrate-forecast
                                                                   {:review review-map
                                                                    :forecast {:target-count default-target-count
                                                                               :target-duration default-target-duration
                                                                               :confidence default-confidence
                                                                               :volatility default-volatility}})
                                                        ;; Update Forecast confidence (convert to 0-100)
                                                        new-confidence (int (* (:confidence calibrated) 100))
                                                        updates (app-db/ForecastsCompanion
                                                                :confidence (bridge/dart-value-int new-confidence))]
                                                    ;; Update Forecast confidence
                                                    (bridge/dart-call
                                                     forecast-bridge/updateForecast
                                                     dao
                                                     (.-id forecast)
                                                     updates))
                                                  (dart-core/Future.value nil)))
                                              forecasts)]
                                      ;; Wait for all calibrations to complete
                                      (dart-core/Future.wait (vec calibration-futures)))))
                            (.catchError (fn [error]
                                         (dart-core/print (str "Error adjusting forecasts: " error))
                                         (dart-core/Future.value nil)))))
                      ;; No Review data, log warning
                      (do
                        (dart-core/print "No review data found for auto-adjust")
                        (dart-core/Future.value nil)))))
            (.catchError (fn [error]
                         (dart-core/print (str "Error in forecast/auto-adjust: " error))
                         (dart-core/Future.value nil))))))))

(defn handle-task-defer
  "Handle task/defer Event
  
  Parameters:
  - ctx: {:db AppDatabase :dao DaoBridge}
  - payload: {:task-id string :defer-at int? (millisecond timestamp, optional, default tomorrow)}
  
  Returns: Future<void>"
  [ctx payload]
  (let [{:keys [dao]} ctx
        {:keys [task-id defer-at]} payload
        defer-date (or defer-at
                       ;; Default defer to tomorrow
                       (+ (-> (dart-core/DateTime.now) (.-millisecondsSinceEpoch))
                          (* 24 60 60 1000)))
        updates (app-db/TasksCompanion
                 :deferAt (bridge/dart-value-int-nullable defer-date))]
    (task/update-task! dao task-id updates)))

(defn handle-forecast-cancel
  "Handle forecast/cancel Event
  
  Parameters:
  - ctx: {:db AppDatabase :dao DaoBridge}
  - payload: {:forecast-id string}
  
  Returns: Future<void>"
  [ctx payload]
  (let [{:keys [dao]} ctx
        {:keys [forecast-id]} payload]
    (forecast/mark-skipped! dao forecast-id)))

(defn handle-forecast-auto-add
  "Handle forecast/auto-add Event (system auto-generated)
  
  Parameters:
  - ctx: {:db AppDatabase :dao DaoBridge}
  - payload: {:task-id string :date int :rule string}
    - task-id: Task ID
    - date: int (yyyyMMdd format, e.g. 20250101)
    - rule: string (rule identifier, e.g. \"perspective-xxx\")
  
  Returns: Future<void>
  
  Note:
  - This is a system auto-generated Forecast
  - source is fixed at 0 (auto)
  - Behavior is identical to manually added Forecasts"
  [ctx payload]
  (let [{:keys [dao]} ctx
        {:keys [task-id date]} payload
        forecast-id (str "forecast-auto-" task-id "-" date)
        now (int (/ (-> (dart-core/DateTime.now) (.-millisecondsSinceEpoch)) 1000))
        now-ms (* now 1000)
        forecast-data {:id forecast-id
                       :task-id task-id
                       :scheduled-date date
                       :done false
                       :skipped false
                       :confidence 50
                       :source 0  ; 0 = auto
                       :created-at now-ms}]
    (forecast/insert-forecast! dao forecast-data)))

;; ============================================================================
;; Event Router
;; ============================================================================

(defn handle-event!
  "Handle Event (route to corresponding Handler)
  
  Parameters:
  - ctx: {:db AppDatabase :dao DaoBridge}
  - event: {:type string :payload map}
  
  Returns: Future<void>"
  [ctx {:keys [type payload]}]
  (logger/log-event "event/handler" "Handling" type {:payload payload})
  ;; Normalize type to keyword for comparison (definitions use keywords)
  (let [type-keyword (if (string? type)
                      (keyword type)
                      type)]
    (logger/debug "event/handler" "Event type details" {:type type
                                                         :type-keyword type-keyword
                                                         :is-keyword (keyword? type)
                                                         :is-string (string? type)
                                                         :namespace (when (keyword? type) (namespace type))
                                                         :name (when (keyword? type) (name type))
                                                         :expected-task-create event-def/task-create})
    (condp = type-keyword
    event-def/task-create
    (handle-task-create ctx payload)
    
    event-def/task-complete
    (handle-task-complete ctx payload)
    
    event-def/task-archive
    (handle-task-archive ctx payload)
    
    event-def/task-assign-project
    (handle-task-assign-project ctx payload)
    
    event-def/task-assign-perspective
    (handle-task-assign-perspective ctx payload)
    
    event-def/project-create
    (handle-project-create ctx payload)
    
    event-def/project-rename
    (handle-project-rename ctx payload)
    
    event-def/project-archive
    (handle-project-archive ctx payload)
    
    event-def/project-restore
    (handle-project-restore ctx payload)
    
    event-def/task-remove-project
    (handle-task-remove-project ctx payload)
    
    event-def/perspective-create
    (handle-perspective-create ctx payload)
    
    event-def/perspective-update-rules
    (handle-perspective-update-rules ctx payload)
    
    event-def/perspective-update-weight
    (handle-perspective-update-weight ctx payload)
    
    event-def/task-remove-perspective
    (handle-task-remove-perspective ctx payload)
    
    event-def/forecast-add
    (handle-forecast-add ctx payload)
    
    event-def/forecast-remove
    (handle-forecast-remove ctx payload)
    
    event-def/forecast-reschedule
    (handle-forecast-reschedule ctx payload)
    
    event-def/forecast-complete
    (handle-forecast-complete ctx payload)
    
    event-def/focus-start
    (handle-focus-start ctx payload)
    
    event-def/focus-pause
    (handle-focus-pause ctx payload)
    
    event-def/focus-complete
    (handle-focus-complete ctx payload)
    
    event-def/focus-abort
    (handle-focus-abort ctx payload)
    
    event-def/review-submit
    (handle-review-submit ctx payload)
    
    event-def/forecast-auto-adjust
    (handle-forecast-auto-adjust ctx payload)
    
    event-def/task-defer
    (handle-task-defer ctx payload)
    
    event-def/forecast-cancel
    (handle-forecast-cancel ctx payload)
    
    event-def/forecast-auto-add
    (handle-forecast-auto-add ctx payload)
    
      ;; Unknown Event type
      (do
        (logger/error "event/handler" "Unknown event type" {:type type
                                                            :type-keyword type-keyword
                                                            :is-keyword (keyword? type)
                                                            :is-string (string? type)
                                                            :namespace (when (keyword? type) (namespace type))
                                                            :name (when (keyword? type) (name type))
                                                            :available-types [event-def/task-create
                                                                               event-def/task-complete
                                                                               event-def/project-create
                                                                               event-def/perspective-create]})
        (dart-core/Future.value nil)))))

