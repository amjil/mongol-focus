(ns minii-focus.core.event.replay-all
  "Full Replay (System Resurrection Button) üîÅ
  
  This is the life-or-death line of event-sourcing.
  
  Features:
  1. Clear all business tables
  2. Read all events in chronological order
  3. Apply each event (without re-recording to TimelineEvents)
  
  Completion criteria:
  - Delete all tasks / forecast / project / perspective data
  - System state fully restored after replay
  - Review / auto-adjust can also be replayed"
  (:require
   [minii-focus.core.db.events :as events]
   [minii-focus.core.event.handler :as handler]
   [minii-focus.core.infra.bridge :as bridge]
   ["package:cljd_mongol_focus/db/bridge/clear_business_tables_bridge.dart" :as clear-bridge]
   ["dart:core" :as dart-core]
   ["dart:convert" :as json]))

;; ============================================================================
;; Helper Functions
;; ============================================================================

(defn timeline-event-to-executable-event
  "Convert TimelineEvent to executable Event format
  
  Parameters:
  - timeline-event: TimelineEvent map (from database)
  
  Returns: Event map (usable by handler)"
  [{:keys [id timestamp type payload]}]
  (let [type-str type  ; Already a string
        payload-map (if (string? payload)
                     (when payload (json/jsonDecode payload))
                     payload)]
    {:id id
     :type (keyword type-str)
     :payload payload-map
     :created-at timestamp
     :source :system}))  ;; Mark as system during replay

(defn apply-event-without-recording!
  "Apply Event (without recording to TimelineEvents)
  
  Parameters:
  - ctx: {:db AppDatabase :dao DaoBridge}
  - event: Event map
  
  Returns: Future<void>
  
  Note: Only for replay scenarios, do not re-record Event"
  [ctx event]
  (let [{:keys [type payload]} event
        type-str (if (keyword? type) (name type) type)]
    ;; Only execute handler, do not record Event
    (handler/handle-event! ctx {:type type-str :payload payload})))

;; ============================================================================
;; Clear Business Tables
;; ============================================================================

(defn clear-all-business-tables!
  "Clear all business tables
  
  Parameters:
  - ctx: {:db AppDatabase :dao DaoBridge}
  
  Returns: Future<void>
  
  Tables cleared:
  - tasks
  - forecasts
  - projects
  - perspectives
  - reviews
  - forecast_calibrations
  - forecast_tuning
  - forecast_items
  - inbox_items
  
  Note: Do not clear timeline_events (this is the fact layer)
  
  ‚ö†Ô∏è Dangerous operation: Only for replay scenarios"
  [ctx]
  (let [{:keys [db]} ctx]
    (dart-core/print "Clearing all business tables...")
    (bridge/dart-call
     clear-bridge/clearAllBusinessTables
     db)))

;; ============================================================================
;; Replay All Events
;; ============================================================================

(defn replay-all-events!
  "Full Replay (System Resurrection Button) üîÅ
  
  Parameters:
  - ctx: {:db AppDatabase :dao DaoBridge}
  
  Returns: Future<void>
  
  Process:
  1. Clear all business tables
  2. Read all events in chronological order
  3. Apply each event (without re-recording to TimelineEvents)
  
  Completion criteria:
  - Delete all tasks / forecast / project / perspective data
  - System state fully restored after replay
  - Review / auto-adjust can also be replayed
  
  This is the life-or-death line of event-sourcing.
  After this step, you have a 'system that's not afraid of rule changes'.
  
  Usage example:
  (replay-all-events! ctx)"
  [ctx]
  (let [{:keys [dao]} ctx]
    (dart-core/print "üîÅ Starting full replay...")
    ;; 1. Clear all business tables
    (-> (clear-all-business-tables! ctx)
        (.then (fn [_]
                 (dart-core/print "‚úÖ Business tables cleared")
                 ;; 2. Read all events in chronological order
                 (events/list-all-ascending! dao)))
        (.then (fn [all-events]
                 (let [event-count (count all-events)]
                   (dart-core/print (str "üìã Found " event-count " events to replay"))
                   (if (zero? event-count)
                     (do
                       (dart-core/print "‚ö†Ô∏è No events to replay")
                       (dart-core/Future.value nil))
                     ;; 3. Apply each event (without re-recording to TimelineEvents)
                     (reduce
                      (fn [acc event]
                        (-> acc
                            (.then (fn [_]
                                    (let [event-id (:id event)
                                          event-type (:type event)]
                                      (dart-core/print (str "‚ñ∂Ô∏è Applying event: " event-id " (" event-type ")"))
                                      (apply-event-without-recording! ctx event)))
                                    (.catchError (fn [error]
                                                  (dart-core/print (str "‚ùå Error applying event " (:id event) ": " error))
                                                  ;; Continue to next event, don't interrupt
                                                  (dart-core/Future.value nil)))))
                      (dart-core/Future.value nil))
                      all-events)))))
        (.then (fn [_]
                 (dart-core/print "‚úÖ Full replay completed")
                 (dart-core/Future.value nil)))
        (.catchError (fn [error]
                      (dart-core/print (str "‚ùå Replay failed: " error))
                      (throw error))))))
