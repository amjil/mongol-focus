(ns minii-focus.core.domain.calibration.review-to-forecast
  "Review → Forecast Calibration Engine
  
  Core Principles:
  - Conservative, reversible, no jitter
  - Don't correct in one step
  - Actual < Expected → Lower target
  - Mood / Focus → Affects confidence
  - Larger deviation → Higher volatility
  - All corrections have upper limits
  
  Completely pure functions, unit testable, can replay historical Reviews"
  (:require
   [minii-focus.core.domain.review.calibrator :as calibrator]
   [minii-focus.core.domain.forecast.generator :as generator]))

;; -------------------------
;; Utility Functions
;; -------------------------

(defn clamp
  "Clamp value within [min, max] range"
  [v min max]
  (cond
    (< v min) min
    (> v max) max
    :else v))

(defn lerp
  "Linear interpolation: a + (b - a) * t"
  [a b t]
  (+ a (* (- b a) t)))

;; -------------------------
;; Calibration Sub-rules
;; -------------------------

(defn calibrate-count
  "Calibrate target count
  
  Rules:
  - Calculate actual/expected ratio
  - Only correct 30% (conservative)
  - Avoid one-time large adjustments"
  [{:keys [expected-count actual-count]}
   target-count]
  (let [ratio (if (zero? expected-count)
                1.0
                (/ actual-count expected-count))
        desired (* target-count ratio)]
    ;; Only correct 30%
    (lerp target-count desired 0.3)))

(defn calibrate-duration
  "Calibrate target duration
  
  Rules:
  - Calculate actual/expected ratio
  - Only correct 30% (conservative)
  - Avoid one-time large adjustments"
  [{:keys [expected-duration actual-duration]}
   target-duration]
  (let [ratio (if (zero? expected-duration)
                1.0
                (/ actual-duration expected-duration))
        desired (* target-duration ratio)]
    (lerp target-duration desired 0.3)))

(defn calibrate-confidence
  "Calibrate confidence
  
  Rules:
  - mood-score: -1.0 ~ +1.0, affects ±0.1
  - focus-score: 0.0 ~ 1.0, baseline 0.5, affects ±0.2
  - Clamped to [0.3, 0.9] range"
  [{:keys [mood-score focus-score]}
   confidence]
  (let [delta (+ (* mood-score 0.1)
                 (* (- focus-score 0.5) 0.2))]
    (-> (+ confidence delta)
        (clamp 0.3 0.9))))

(defn calibrate-volatility
  "Calibrate volatility
  
  Rules:
  - Larger deviation → Higher volatility
  - Increase by error * 0.05 each time
  - Clamped to [0.1, 0.5] range"
  [{:keys [expected-count actual-count]}
   volatility]
  (let [error (abs (- expected-count actual-count))
        bump (* error 0.05)]
    (-> (+ volatility bump)
        (clamp 0.1 0.5))))

;; -------------------------
;; Main Entry
;; -------------------------

(defn calibrate-forecast
  "Calibrate Forecast parameters
  
  Input:
  {:review
   {:expected-count 10
    :actual-count 7
    :expected-duration 300
    :actual-duration 420
    :mood-score -0.2
    :focus-score 0.6}
   
   :forecast
   {:target-count 10.0
    :target-duration 300.0
    :confidence 0.7
    :volatility 0.2}}
  
  Output:
  {:target-count 9.0
   :target-duration 330.0
   :confidence 0.65
   :volatility 0.25}"
  [{:keys [review forecast]}]
  (let [new-count
        (calibrate-count review (:target-count forecast))

        new-duration
        (calibrate-duration review (:target-duration forecast))

        new-confidence
        (calibrate-confidence review (:confidence forecast))

        new-volatility
        (calibrate-volatility review (:volatility forecast))]

    {:target-count new-count
     :target-duration new-duration
     :confidence new-confidence
     :volatility new-volatility}))

;; -------------------------
;; New Entry Function (Rule-based Calibration System)
;; -------------------------

(defn review->forecast!
  "Review → Forecast Auto-calibration Entry Function
  
  Parameters:
  {:signals [ReviewSignal ...]
   :total-slots int (total forecast slot count)
   :period int (period identifier, e.g., yyyyMMdd)}
  
  Returns: [Forecast Draft map ...]
  
  Process:
  1. Apply calibration rules to each Perspective
  2. Weight normalization
  3. Generate Forecast Draft list
  
  Note: The returned Draft list needs to be passed to Drift repository for batch insert"
  [{:keys [signals total-slots period]}]
  (let [calibrated (calibrator/calibrate-all
                    {:signals signals
                     :total-slots total-slots})
        drafts     (generator/generate-forecast-drafts calibrated period)]
    drafts))

