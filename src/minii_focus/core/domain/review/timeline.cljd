(ns minii-focus.core.domain.review.timeline
  "Review → Timeline Aggregation Statistics
  
  This is Review's fact engine, not UI, not summary text, but:
  Use Timeline Events to calculate 'what I was really doing during this period'.
  
  ⚠️ Review does not directly modify database
  ⚠️ Review only calculates + generates calibration suggestions
  
  Input:
  - Time range: start-ts ~ end-ts
  - Data source: timeline_events
  
  Output:
  {:total-events 42
   :focus-minutes 180
   :task-completed 7
   :forecast-done 5
   :forecast-skipped 2
   :by-day {20250101 {:focus 60 :tasks 2}
            20250102 {:focus 120 :tasks 5}}
   :by-perspective {\"career\" {:focus 120 :events 10}
                    \"language\" {:focus 60 :events 4}}
   :overdue-score -3}"
  (:require
   ["dart:convert" :as dart-convert]
   [minii-focus.core.utils.time :as time]
   [minii-focus.core.db.timeline :as timeline]))

;; ============================================================================
;; I. Event Conversion (Dart → Clojure)
;; ============================================================================

(defn dart-event->map
  "Convert Dart TimelineEvent to Clojure map
  
  Parameters:
  - dart-event: TimelineEvent object
  
  Returns: {:timestamp ... :type ... :duration ... :perspectives [...]}"
  [dart-event]
  (let [perspectives-json (.perspectivesJson dart-event)
        perspectives (if perspectives-json
                       (try
                         (dart-convert/jsonDecode perspectives-json)
                         (catch :default _
                           []))
                       [])]
    {:id (.id dart-event)
     :timestamp (.timestamp dart-event)
     :type (.type dart-event)
     :entity-type (.entityType dart-event)
     :entity-id (.entityId dart-event)
     :title (.title dart-event)
     :duration (or (.durationMinutes dart-event) 0)
     :perspectives perspectives}))

;; ============================================================================
;; II. Event Classifier (Core)
;; ============================================================================

(defn classify-event
  "Event Classifier
  
  80% of Review's correctness is here
  
  Returns: :focus | :task | :forecast-done | :forecast-skipped | :review | :other"
  [event]
  (case (:type event)
    "focus-session"     :focus
    "task-complete"     :task
    "forecast-done"     :forecast-done
    "forecast-skipped"  :forecast-skipped
    "review"            :review
    :other))

;; ============================================================================
;; III. Base Accumulators (Pure Functions)
;; ============================================================================

(defn aggregate-totals
  "Total Statistics Accumulator
  
  Parameters:
  - acc: accumulator map
  - event: event map
  
  Returns: updated accumulator"
  [acc event]
  (let [k (classify-event event)]
    (-> acc
        (update :total-events inc)
        (cond-> (= k :focus)
          (update :focus-minutes + (or (:duration event) 0)))
        (cond-> (= k :task)
          (update :task-completed inc))
        (cond-> (= k :forecast-done)
          (update :forecast-done inc))
        (cond-> (= k :forecast-skipped)
          (update :forecast-skipped inc)))))

(defn aggregate-by-day
  "Daily Aggregation Accumulator
  
  Parameters:
  - acc: {:by-day {...}}
  - event: event map
  
  Returns: updated accumulator"
  [acc event]
  (let [day (time/ts->yyyymmdd (:timestamp event))
        k   (classify-event event)]
    (update acc day
            (fn [m]
              (-> (or m {:focus 0 :tasks 0})
                  (cond-> (= k :focus)
                    (update :focus + (or (:duration event) 0)))
                  (cond-> (= k :task)
                    (update :tasks inc)))))))

(defn aggregate-by-perspective
  "Perspective Aggregation Accumulator (Key)
  
  ⚠️ Events without perspective are directly ignored, no forced attribution
  
  Parameters:
  - acc: {:by-perspective {...}}
  - event: event map
  
  Returns: updated accumulator"
  [acc event]
  (let [ps (:perspectives event)
        k  (classify-event event)
        dur (or (:duration event) 0)]
    (if (empty? ps)
      acc
      (reduce
       (fn [m p]
         (update m p
                 (fn [x]
                   (-> (or x {:focus 0 :events 0})
                       (update :events inc)
                       (cond-> (= k :focus)
                         (update :focus + dur))))))
       acc
       ps))))

;; ============================================================================
;; IV. Overdue / Stress Score
;; ============================================================================

(defn calc-overdue-score
  "Calculate Overdue Score (minimal usable)
  
  Minimal version: Skip penalty > Completion reward
  
  Parameters:
  - result: {:forecast-done ... :forecast-skipped ...}
  
  Returns: int"
  [{:keys [forecast-done forecast-skipped]}]
  (- forecast-done (* 2 forecast-skipped)))

;; ============================================================================
;; V. Complete Review Aggregation Main Function
;; ============================================================================

(defn review-from-events
  "Generate Review statistics from event list
  
  Parameters:
  - events: vector of event maps
  
  Returns: review map"
  [events]
  (let [init
        {:total-events 0
         :focus-minutes 0
         :task-completed 0
         :forecast-done 0
         :forecast-skipped 0
         :by-day {}
         :by-perspective {}}
        result
        (reduce
         (fn [acc event]
           (-> acc
               (aggregate-totals event)
               (update :by-day aggregate-by-day event)
               (update :by-perspective aggregate-by-perspective event)))
         init
         events)]
    (assoc result
           :overdue-score
           (calc-overdue-score result))))

;; ============================================================================
;; VI. Complete DAO + Review Call
;; ============================================================================

(defn run-review!
  "Run Review aggregation statistics
  
  Parameters:
  - dao-bridge: DaoBridge instance
  - start-ts: int (timestamp, seconds)
  - end-ts: int (timestamp, seconds)
  
  Returns: Future<review-map>
  
  Usage example:
  (run-review! dao-bridge 1713427200 1713513600)"
  [dao-bridge start-ts end-ts]
  (let [dart-events-future (timeline/query-range dao-bridge start-ts end-ts)]
    (-> dart-events-future
        (.then (fn [dart-events]
                 (let [events (map dart-event->map dart-events)]
                   (review-from-events events)))))))

