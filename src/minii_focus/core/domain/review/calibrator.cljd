(ns minii-focus.core.domain.review.calibrator
  "Rule Combiner and Calibration Main Flow
  
  Combines multiple rules serially to calibrate each Perspective.
  Core functions: calibrate-perspective and calibrate-all."
  (:require
   [minii-focus.core.domain.review.rules.util :as u]
   [minii-focus.core.domain.review.rules
    :refer [rule-under-invested
            rule-high-done-but-insufficient
            rule-over-invested
            rule-high-abandon]]))

;; Rule List (Serial Execution)
(def rules
  [rule-under-invested
   rule-high-done-but-insufficient
   rule-over-invested
   rule-high-abandon])

(defrecord CalibratedForecast
  [perspective-id
   next-weight            ;; double
   forecast-count         ;; int
   forecast-type          ;; :deep :shallow :maintenance
   frozen?])              ;; boolean

(defn calibrate-perspective
  "Calibrate single Perspective
  
  Parameters:
  - perspective-info: {:perspective-id ... :expected-weight ...}
  - signal: ReviewSignal
  - base-forecast-count: int (base forecast count)
  
  Returns: CalibratedForecast"
  [{:keys [perspective-id expected-weight]} signal base-forecast-count]
  (let [initial
        {:perspective-id perspective-id
         :next-weight expected-weight
         :forecast-count base-forecast-count
         :forecast-type :maintenance
         :frozen? false}
        
        after-rules
        (reduce (fn [forecast rule]
                  (rule signal forecast))
                initial
                rules)
        
        clamped-weight (u/clamp (:next-weight after-rules) 0.05 0.6)
        clamped-count (max 0 (:forecast-count after-rules))
        
        final-map
        (assoc after-rules
               :next-weight clamped-weight
               :forecast-count clamped-count)]
    (map->CalibratedForecast final-map)))

(defn calibrate-all
  "Overall Calibration Flow (Review â†’ Forecast)
  
  Parameters:
  - {:signals [ReviewSignal ...] :total-slots int}
  
  Returns: [CalibratedForecast ...]
  
  Flow:
  1. Calculate base slots for each Perspective
  2. Apply calibration rules to each Perspective
  3. Weight normalization"
  [{:keys [signals total-slots]}]
  ;; signals: [ReviewSignal ...]
  (let [base-slots
        (/ total-slots (count signals))

        calibrated
        (map #(calibrate-perspective
               {:perspective-id (:perspective-id %)
                :expected-weight (:expected-weight %)}
               %
               base-slots)
             signals)

        total-weight
        (reduce + (map :next-weight calibrated))]

    ;; Weight normalization (avoid division by 0)
    (if (zero? total-weight)
      calibrated
      (map (fn [forecast]
             (let [normalized-weight (/ (:next-weight forecast) total-weight)]
               (assoc forecast :next-weight normalized-weight)))
           calibrated))))

