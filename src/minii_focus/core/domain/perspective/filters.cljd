(ns minii-focus.core.domain.perspective.filters
  "Filter Builder DSL - Elegant Filter Building Tool
  
  Provides concise functions to build FilterSpec, avoiding manual writing of complex map structures.
  
  Usage examples:
  ;; Old way (verbose)
  {:field :status :op := :value :active}
  
  ;; New way (elegant)
  (eq :status :active)
  (lt :due-at :today)
  (in :tags [:work :urgent])
  
  ;; Combine multiple filters
  [(eq :status :active)
   (lt :due-at :today)
   (is-not-null :project-id)]"
  (:require
   ["dart:convert" :as json]
   [minii-focus.core.utils.logger :as logger]))

;; ============================================================================
;; Core Filter Builder
;; ============================================================================

(defn where
  "Generic filter building function
  
  Parameters:
  - field: Field name (keyword)
  - op: Operator (keyword)
  - value: Value (any)
  
  Returns: FilterSpec map
  
  Example:
  (where :status := :active)
  => {:field :status :op := :value :active}"
  [field op value]
  {:field field
   :op op
   :value value})

;; ============================================================================
;; Equality Operators
;; ============================================================================

(defn eq
  "Equals (==)
  
  Example:
  (eq :status :active)
  => {:field :status :op := :value :active}"
  [field value]
  (where field := value))

(defn not-eq
  "Not equals (!=)
  
  Example:
  (not-eq :status :completed)
  => {:field :status :op :!= :value :completed}"
  [field value]
  (where field :!= value))

;; ============================================================================
;; Comparison Operators
;; ============================================================================

(defn lt
  "Less than (<)
  
  Example:
  (lt :due-at :today)
  => {:field :due-at :op :< :value :today}"
  [field value]
  (where field :< value))

(defn lte
  "Less than or equal (<=)
  
  Example:
  (lte :priority 5)
  => {:field :priority :op :<= :value 5}"
  [field value]
  (where field :<= value))

(defn gt
  "Greater than (>)
  
  Example:
  (gt :priority 3)
  => {:field :priority :op :> :value 3}"
  [field value]
  (where field :> value))

(defn gte
  "Greater than or equal (>=)
  
  Example:
  (gte :priority 2)
  => {:field :priority :op :>= :value 2}"
  [field value]
  (where field :>= value))

;; ============================================================================
;; Membership Operators
;; ============================================================================

(defn in
  "In list (in)
  
  Example:
  (in :status [:active :waiting])
  => {:field :status :op :in :value [:active :waiting]}"
  [field values]
  (where field :in values))

(defn within
  "Within range (within)
  
  Example:
  (within :due-at {:start :week-start :end :week-end})
  => {:field :due-at :op :within :value {:start :week-start :end :week-end}}"
  [field range-map]
  (where field :within range-map))

;; ============================================================================
;; Null Check Operators
;; ============================================================================

(defn is-null
  "Field is null (is-null)
  
  Example:
  (is-null :project-id)
  => {:field :project-id :op :is-null :value nil}"
  [field]
  (where field :is-null nil))

(defn is-not-null
  "Field is not null (is-not-null)
  
  Example:
  (is-not-null :project-id)
  => {:field :project-id :op :is-not-null :value nil}"
  [field]
  (where field :is-not-null nil))

;; ============================================================================
;; Convenience Functions
;; ============================================================================

(defn combine
  "Combine multiple filters
  
  Parameters:
  - filters: Filter list or single filter
  
  Returns: Filter vector
  
  Example:
  (combine (eq :status :active) (lt :due-at :today))
  => [{:field :status :op := :value :active}
      {:field :due-at :op :< :value :today}]
  
  (combine [(eq :status :active) (lt :due-at :today)])
  => [{:field :status :op := :value :active}
      {:field :due-at :op :< :value :today}]"
  [& filters]
  (let [flattened (flatten filters)]
    (vec (filter some? flattened))))

(defn active
  "Convenience function: status is active
  
  Example:
  (active)
  => {:field :status :op := :value :active}"
  []
  (eq :status :active))

(defn completed
  "Convenience function: status is completed
  
  Example:
  (completed)
  => {:field :status :op := :value :completed}"
  []
  (eq :status :completed))

(defn waiting
  "Convenience function: status is waiting
  
  Example:
  (waiting)
  => {:field :status :op := :value :waiting}"
  []
  (eq :status :waiting))

(defn due-today
  "Convenience function: due today
  
  Example:
  (due-today)
  => {:field :due-at :op := :value :today}"
  []
  (eq :due-at :today))

(defn due-before
  "Convenience function: due before specified date
  
  Example:
  (due-before :today)
  => {:field :due-at :op :< :value :today}"
  [date]
  (lt :due-at date))

(defn due-on-or-before
  "Convenience function: due on or before specified date
  
  Example:
  (due-on-or-before :today)
  => {:field :due-at :op :<= :value :today}"
  [date]
  (lte :due-at date))

(defn flagged
  "Convenience function: is flagged
  
  Example:
  (flagged)
  => {:field :flagged :op := :value true}"
  []
  (eq :flagged true))

(defn not-flagged
  "Convenience function: is not flagged
  
  Example:
  (not-flagged)
  => {:field :flagged :op := :value false}"
  []
  (eq :flagged false))

(defn in-project
  "Convenience function: belongs to specified project
  
  Example:
  (in-project \"project-123\")
  => {:field :project-id :op := :value \"project-123\"}"
  [project-id]
  (eq :project-id project-id))

(defn no-project
  "Convenience function: no project (Inbox)
  
  Example:
  (no-project)
  => {:field :project-id :op :is-null :value nil}"
  []
  (is-null :project-id))

;; ============================================================================
;; Serialization / Deserialization
;; ============================================================================

(defn clj-to-dart
  "Convert Clojure data structure to Dart serializable format
  
  Parameters:
  - val: Any Clojure value
  
  Returns: Dart serializable value"
  [val]
  (cond
    (nil? val) nil
    (keyword? val) (name val)
    (vector? val) (mapv clj-to-dart val)
    (map? val) (reduce-kv (fn [acc k v]
                            (assoc acc
                                   (if (keyword? k) (name k) (str k))
                                   (clj-to-dart v)))
                          {}
                          val)
    (seq? val) (vec (map clj-to-dart val))
    (set? val) (vec (map clj-to-dart val))
    :else val))

(defn filters-to-json
  "Convert filters vector to JSON string
  
  Parameters:
  - filters: Filter vector
  
  Returns: JSON string"
  [filters]
  (let [filters-count (count filters)
        dart-data (clj-to-dart (mapv (fn [f]
                                       {:field (name (:field f))
                                        :op (name (:op f))
                                        :value (clj-to-dart (:value f))})
                                     filters))
        json-result (json/jsonEncode dart-data)]
    (logger/debug "filters" "filters-to-json conversion" {:filters-count filters-count
                                                   :filters filters
                                                   :json-result json-result
                                                   :json-length (count json-result)})
    json-result))

(defn json-to-filters
  "Parse filters vector from JSON string
  
  Parameters:
  - json-str: JSON string
  
  Returns: Filter vector"
  [json-str]
  (try
    (logger/debug "filters" "json-to-filters starting parse" {:json-str json-str
                                                       :json-length (count json-str)})
    (let [parsed (json/jsonDecode json-str)
          ;; In ClojureDart, Dart List may be neither vector nor seq
          ;; Try to convert directly to vector
          parsed-vec (try
                       (cond
                         (vector? parsed) parsed
                         (seq? parsed) (vec parsed)
                         ;; Directly try to convert to vector (for Dart List)
                         :else (vec parsed))
                       (catch Exception _
                         nil))]
      (logger/debug "filters" "json-to-filters parse result" {:parsed parsed
                                                          :is-vector? (vector? parsed)
                                                          :is-seq? (seq? parsed)
                                                          :is-map? (map? parsed)
                                                          :is-string? (string? parsed)
                                                          :parsed-vec parsed-vec})
      (if parsed-vec
        (let [result (mapv (fn [f]
                            {:field (keyword (get f "field"))
                             :op (keyword (get f "op"))
                             :value (get f "value")})
                          parsed-vec)]
          (logger/info "filters" "json-to-filters parse success" {:result-count (count result)
                                                            :result result})
          result)
        (do
          (logger/warn "filters" "json-to-filters parse result cannot be converted to vector" {:parsed parsed
                                                                             :is-vector? (vector? parsed)
                                                                             :is-seq? (seq? parsed)
                                                                             :is-map? (map? parsed)
                                                                             :is-string? (string? parsed)})
          [])))
    (catch Exception e
      (logger/error "filters" "json-to-filters parse failed" {:json-str json-str
                                                          :error (str e)})
      [])))

