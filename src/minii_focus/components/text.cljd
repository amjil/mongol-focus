(ns minii-focus.components.text
  (:require
   ["package:flutter/material.dart" :as m]
   ["package:mongol/mongol.dart" :as mongol]
   [cljd.flutter :as f]))

;; ============================================
;; 3.1 MongolTextBlock
;; Basic vertical text block
;; ============================================

(defn mongol-text-block
  "Auto vertical layout, supports block selection, supports Focus highlighting"
  [{:keys [text style is-focused on-tap]}]
  (f/widget
   :let [base-style (m/TextStyle
                     .fontSize 16
                     .fontFamily "OnonSoninSans"
                     .height 1.6)
         ;; TextStyle is not a map, use copyWith/merge chaining
         final-style (-> base-style
                         (cond-> is-focused
                           (.copyWith .color m/Colors.blue.shade300))
                         (.merge style))]
   (m/GestureDetector
    .onTap on-tap
    .child (mongol/MongolText
            text
            .style final-style
            .textAlign mongol/MongolTextAlign.top))))

;; ============================================
;; 3.2 MongolTaskItem
;; Task / subtask display component
;; ============================================

(def task-status-colors
  {:idle m/Colors.grey
   :active m/Colors.blue
   :blocked m/Colors.red
   :completed m/Colors.green})

(defn mongol-task-item
  "Status: idle, active, blocked, completed
   Swipe up: Enter Focus (vertical swipe up)
   Swipe left: Enter Focus (horizontal swipe left, for compatibility)
   Swipe right: Return/move
   Long press: Structure adjustment
   Supports showing blocked status and hierarchy level
   on-complete: callback for marking task as completed
   selection-mode: boolean, if true shows checkbox for selection
   selected: boolean, if true checkbox is checked
   on-selection-changed: callback when selection changes"
  [{:keys [content status on-long-press on-tap on-swipe-up on-swipe-left on-swipe-right blocked? level parent-content on-complete selection-mode selected on-selection-changed]}]
  (f/widget
   :let [effective-status (if (and blocked? (not= status :completed)) :blocked status)
         effective-color (get task-status-colors effective-status m/Colors.grey)
         indent-width (* (or level 0) 20)]
   (m/GestureDetector
    .onLongPress (when (not selection-mode) on-long-press)
    .onTap (if selection-mode
             (when on-selection-changed
               (fn [] (on-selection-changed (not selected))))
             on-tap)
    ;; Vertical swipe up: Enter Focus (for vertical writing layout)
    .onVerticalDragEnd (when (and (not selection-mode) (or on-swipe-up on-swipe-left))
                         (fn [details]
                           (let [velocity (.-primaryVelocity details)]
                             ;; Upward swipe (negative velocity in vertical direction)
                             (when (and velocity (< velocity -500))
                               (when on-swipe-up (on-swipe-up))
                               ;; Fallback to on-swipe-left if on-swipe-up not provided
                               (when (and (not on-swipe-up) on-swipe-left) (on-swipe-left))))))
    ;; Horizontal swipe left: Enter Focus (for compatibility)
    .onHorizontalDragEnd (when (not selection-mode)
                           (fn [details]
                             (let [velocity (.-primaryVelocity details)]
                               (cond
                                 ;; Swipe left: Enter Focus
                                 (and velocity (< velocity -500) (or on-swipe-left on-swipe-up))
                                 (do
                                   (when on-swipe-left (on-swipe-left))
                                   (when (and (not on-swipe-left) on-swipe-up) (on-swipe-up)))
                                 ;; Swipe right: Return/move
                                 (and velocity (> velocity 500) on-swipe-right)
                                 (on-swipe-right)))))
    .child (m/Column
            .mainAxisSize m/MainAxisSize.min
            .children
            [(if (true? selection-mode)
               (m/Checkbox
                .value selected
                .onChanged (when on-selection-changed
                             (fn [value]
                               (on-selection-changed value))))
               (m/SizedBox))
             (if (> indent-width 0)
               (m/Container
                .width indent-width)
               (m/SizedBox))
             (m/Expanded
              .child
              (m/Container
               .padding (m/EdgeInsets.all 12)
               .decoration (m/BoxDecoration
                            .border (m/Border
                                     .top (m/BorderSide
                                           .color effective-color
                                           .width 3))
                            .color (cond
                                     (and selection-mode selected) m/Colors.blue.shade50
                                     blocked? m/Colors.grey.shade100
                                     :else nil))
               .child (m/Column
                       .crossAxisAlignment m/CrossAxisAlignment.start
                       .mainAxisSize m/MainAxisSize.min
                       .children
                       [(condp = status
                          :idle (m/Icon m/Icons.radio_button_unchecked)
                          :active (m/Icon m/Icons.radio_button_checked)
                          :completed (m/Icon m/Icons.check_circle)
                          :blocked (m/Icon m/Icons.block)
                          :else (m/Icon m/Icons.radio_button_unchecked))
                        (m/SizedBox .height 8)
                        (m/Row
                         .mainAxisSize m/MainAxisSize.min
                         .children
                         [(m/Flexible
                           .fit m/FlexFit.loose
                           .child
                           (mongol-text-block
                            {:text content
                             :is-focused (= status :active)}))
                          (m/Column
                           .mainAxisAlignment m/MainAxisAlignment.end
                           .children
                           [(if (some? parent-content)
                              (m/Column
                               .children
                               [(m/Icon m/Icons.subdirectory_arrow_right
                                        .size 12
                                        .color m/Colors.grey.shade600)
                                (m/SizedBox .height 4)
                                (mongol-text-block
                                 {:text (str "Project: " parent-content)
                                  :style (m/TextStyle
                                          .fontSize 12
                                          .color m/Colors.grey.shade600)})])
                              (m/SizedBox))
                            (m/SizedBox .height 8)
                            (if blocked?
                              (m/Column
                               .children
                               [(m/Icon m/Icons.block
                                        .size 12
                                        .color m/Colors.red.shade600)
                                (m/SizedBox .width 4)
                                (mongol-text-block
                                 {:text "Blocked by parent"
                                  :style (m/TextStyle
                                          .fontSize 10
                                          .color m/Colors.red.shade600)})])
                              (m/SizedBox))])])])))
             (m/SizedBox .height 8)
             ;; Completion checkbox/button
             (if (and (not selection-mode) on-complete (not= status :completed))
               (m/IconButton
                .icon (m/Icon m/Icons.check_circle_outline)
                .iconSize 20
                .color m/Colors.green.shade600
                .onPressed (fn [] (on-complete))
                .tooltip "Mark as completed")
               (m/SizedBox))]))))

;; ============================================
;; 3.3 MongolNoteBlock
;; Thought / note block component
;; ============================================

(defn mongol-note-block
  "Nestable, can link tasks/projects"
  [{:keys [content nested-blocks]}]
  (f/widget
   (m/Column
    .crossAxisAlignment m/CrossAxisAlignment.start
    .children
    [(m/Container
      .padding (m/EdgeInsets.all 8)
      .child (mongol-text-block {:text content}))
     (if (seq nested-blocks)
       (m/Container
        .padding (m/EdgeInsets.only .left 20)
        .child (m/Column
                .children (map (fn [block]
                                 (mongol-note-block block))
                               nested-blocks)))
       (m/SizedBox))])))

